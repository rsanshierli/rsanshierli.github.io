<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Mist","version":"7.7.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":true,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="Abstract 本文提出了一种端到端的关系抽取模型GraphRel，它使用GCN来共同学习命名实体和关系。与之前的基线相比，我们通过关系加权GCN来考虑命名实体和关系之间的交互，以更好地提取关系。线性结构和依赖结构都用于提取文本的序列和区域特征，并且完整的单词图还用于提取文本中所有单词对的隐含特征。使用基于图的方法，重叠关系的预测比先前的序列方法有了很大的改进。我们在两个公共数据集上评估Gra">
<meta property="og:type" content="article">
<meta property="og:title" content="《GraphRel：Modeling Text as Relational Graphs for Joint Entity and Relation Extraction》阅读记录">
<meta property="og:url" content="http://yoursite.com/2020/03/04/article-1/index.html">
<meta property="og:site_name" content="想吃煎饼果子">
<meta property="og:description" content="Abstract 本文提出了一种端到端的关系抽取模型GraphRel，它使用GCN来共同学习命名实体和关系。与之前的基线相比，我们通过关系加权GCN来考虑命名实体和关系之间的交互，以更好地提取关系。线性结构和依赖结构都用于提取文本的序列和区域特征，并且完整的单词图还用于提取文本中所有单词对的隐含特征。使用基于图的方法，重叠关系的预测比先前的序列方法有了很大的改进。我们在两个公共数据集上评估Gra">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20191022211619599.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTMxMTgx,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/2019102221192439.png">
<meta property="og:image" content="https://private.codecogs.com/gif.latex?%5Cmu">
<meta property="og:image" content="https://private.codecogs.com/gif.latex?N(u)">
<meta property="og:image" content="https://private.codecogs.com/gif.latex?%5Cmu">
<meta property="og:image" content="https://private.codecogs.com/gif.latex?%5Cmu">
<meta property="og:image" content="https://private.codecogs.com/gif.latex?h_%7Bv%7D%5E%7Bl%7D">
<meta property="og:image" content="https://private.codecogs.com/gif.latex?v">
<meta property="og:image" content="https://private.codecogs.com/gif.latex?l">
<meta property="og:image" content="https://private.codecogs.com/gif.latex?W">
<meta property="og:image" content="https://private.codecogs.com/gif.latex?b">
<meta property="og:image" content="https://private.codecogs.com/gif.latex?h%5Cin%20%5Cmathbb%7BR%7D%5E%7Bf%7D%252C%20W%5Cin%20%5Cmathbb%7BR%7D%5E%7Bf%5Ctimes%20f%7D%252C%20b%5Cin%20%5Cmathbb%7BR%7D%5E%7Bf%7D">
<meta property="og:image" content="https://private.codecogs.com/gif.latex?f">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20191023092533484.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTMxMTgx,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://private.codecogs.com/gif.latex?h_%7Bu%7D%5E%7B0%7D">
<meta property="og:image" content="https://private.codecogs.com/gif.latex?u">
<meta property="og:image" content="https://private.codecogs.com/gif.latex?Word(u)">
<meta property="og:image" content="https://private.codecogs.com/gif.latex?Pos(u)">
<meta property="og:image" content="https://private.codecogs.com/gif.latex?u">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20191023094653902.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20191023110123301.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTMxMTgx,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://private.codecogs.com/gif.latex?h_%7Bu%7D%5E%7Bl%7D">
<meta property="og:image" content="https://private.codecogs.com/gif.latex?u">
<meta property="og:image" content="https://private.codecogs.com/gif.latex?l">
<meta property="og:image" content="https://private.codecogs.com/gif.latex?%5Coverrightarrow%7BN%7D(u)">
<meta property="og:image" content="https://private.codecogs.com/gif.latex?u">
<meta property="og:image" content="https://private.codecogs.com/gif.latex?%5Coverleftarrow%7BN%7D(u)">
<meta property="og:image" content="https://private.codecogs.com/gif.latex?u">
<meta property="og:image" content="https://private.codecogs.com/gif.latex?u">
<meta property="og:image" content="https://private.codecogs.com/gif.latex?W">
<meta property="og:image" content="https://private.codecogs.com/gif.latex?b">
<meta property="og:image" content="https://private.codecogs.com/gif.latex?%5Coverrightarrow%7BW%7D%252C%20%5Coverrightarrow%7Bb%7D%252C%20%5Coverleftarrow%7BW%7D%252C%5Coverleftarrow%7Bb%7D">
<meta property="og:image" content="https://private.codecogs.com/gif.latex?eloss_%7B1p%7D">
<meta property="og:image" content="https://private.codecogs.com/gif.latex?W_%7Br%7D%5E%7B1%7D%252C%20W_%7Br%7D%5E%7B2%7D%252C%20W_%7Br%7D%5E%7B3%7D">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20191023112951951.png">
<meta property="og:image" content="https://private.codecogs.com/gif.latex?S_%7B(%5Comega%201%252C%20r%252C%20%5Comega%202)%7D">
<meta property="og:image" content="https://private.codecogs.com/gif.latex?r">
<meta property="og:image" content="https://private.codecogs.com/gif.latex?(%5Comega%201%252C%20%5Comega%202)">
<meta property="og:image" content="https://private.codecogs.com/gif.latex?(%5Comega%201%252C%20%5Comega%202)">
<meta property="og:image" content="https://private.codecogs.com/gif.latex?S_%7B(%5Comega%201%252C%20r%252C%20%5Comega%202))%7D">
<meta property="og:image" content="https://private.codecogs.com/gif.latex?S_%7B(%5Comega%202%252C%20r%252C%20%5Comega%201))%7D">
<meta property="og:image" content="https://private.codecogs.com/gif.latex?(%5Comega%201%252C%20%5Comega%202)">
<meta property="og:image" content="https://private.codecogs.com/gif.latex?S_%7B(%5Comega%201%252C%20null%252C%20%5Comega%202))%7D">
<meta property="og:image" content="https://private.codecogs.com/gif.latex?S_%7B(%5Comega%201%252C%20r%252C%20%5Comega%202))%7D">
<meta property="og:image" content="https://private.codecogs.com/gif.latex?P_%7Br%7D_%7B(%5Comega%201%252C%20%5Comega%202))%7D">
<meta property="og:image" content="https://private.codecogs.com/gif.latex?r">
<meta property="og:image" content="https://private.codecogs.com/gif.latex?(%5Comega%201%252C%20%5Comega%202)">
<meta property="og:image" content="https://private.codecogs.com/gif.latex?P_%7Br%7D_%7B(%5Comega%201%252C%20%5Comega%202))%7D">
<meta property="og:image" content="https://private.codecogs.com/gif.latex?rloss_%7B1p%7D">
<meta property="og:image" content="https://private.codecogs.com/gif.latex?eloss_%7B1p%7D">
<meta property="og:image" content="https://private.codecogs.com/gif.latex?rloss_%7B1p%7D">
<meta property="og:image" content="https://private.codecogs.com/gif.latex?r">
<meta property="og:image" content="https://private.codecogs.com/gif.latex?(%5Comega%201%252C%20%5Comega%202)">
<meta property="og:image" content="https://private.codecogs.com/gif.latex?P_%7Br%7D_%7B(%5Comega%201%252C%20%5Comega%202)%7D">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20191023193638111.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTMxMTgx,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20191023194320558.png">
<meta property="og:image" content="https://private.codecogs.com/gif.latex?P_%7Br%7D_%7B(u%252C%20v)%7D">
<meta property="og:image" content="https://private.codecogs.com/gif.latex?r">
<meta property="og:image" content="https://private.codecogs.com/gif.latex?u">
<meta property="og:image" content="https://private.codecogs.com/gif.latex?v">
<meta property="og:image" content="https://private.codecogs.com/gif.latex?W_%7Br%7D">
<meta property="og:image" content="https://private.codecogs.com/gif.latex?b_%7Br%7D">
<meta property="og:image" content="https://private.codecogs.com/gif.latex?r">
<meta property="og:image" content="https://private.codecogs.com/gif.latex?V">
<meta property="og:image" content="https://private.codecogs.com/gif.latex?R">
<meta property="og:image" content="https://private.codecogs.com/gif.latex?eloss_%7B2p%7D">
<meta property="og:image" content="https://private.codecogs.com/gif.latex?rloss_%7B2p%7D">
<meta property="og:image" content="https://private.codecogs.com/gif.latex?eloss_%7B1p%7D">
<meta property="og:image" content="https://private.codecogs.com/gif.latex?eloss_%7B2p%7D">
<meta property="og:image" content="https://private.codecogs.com/gif.latex?(%5Comega%201%252C%20%5Comega%202)">
<meta property="og:image" content="https://private.codecogs.com/gif.latex?P_%7Br%7D_%7B(%5Comega%201%252C%20%5Comega%202)%7D">
<meta property="og:image" content="https://private.codecogs.com/gif.latex?rloss_%7B1p%7D">
<meta property="og:image" content="https://private.codecogs.com/gif.latex?rloss_%7B2p%7D">
<meta property="og:image" content="https://private.codecogs.com/gif.latex?%5Calpha">
<meta property="og:image" content="https://private.codecogs.com/gif.latex?loss_%7Ball%7D">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20191023202501130.png">
<meta property="og:image" content="https://private.codecogs.com/gif.latex?P_%7B(Obama%252C%20States)%7D">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20191023215945553.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTMxMTgx,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://private.codecogs.com/gif.latex?GraphRel_%7B1p%7D">
<meta property="og:image" content="https://private.codecogs.com/gif.latex?GraphRel_%7B1-hop%7D">
<meta property="og:image" content="https://private.codecogs.com/gif.latex?GraphRel_%7B1-hop%7D">
<meta property="og:image" content="https://private.codecogs.com/gif.latex?GraphRel_%7B2p%7D">
<meta property="og:image" content="https://private.codecogs.com/gif.latex?GraphRel_%7B1p%7D">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20191023215923980.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTMxMTgx,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/2019102322341628.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTMxMTgx,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20191023223442193.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTMxMTgx,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/2019102409370847.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTMxMTgx,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20191024100130760.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTMxMTgx,size_16,color_FFFFFF,t_70">
<meta property="article:published_time" content="2020-03-04T10:17:10.000Z">
<meta property="article:modified_time" content="2020-03-04T12:23:15.988Z">
<meta property="article:author" content="R">
<meta property="article:tag" content="论文记录">
<meta property="article:tag" content="NLP">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://img-blog.csdnimg.cn/20191022211619599.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTMxMTgx,size_16,color_FFFFFF,t_70">

<link rel="canonical" href="http://yoursite.com/2020/03/04/article-1/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true
  };
</script>

  <title>《GraphRel：Modeling Text as Relational Graphs for Joint Entity and Relation Extraction》阅读记录 | 想吃煎饼果子</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">想吃煎饼果子</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">要努力变优秀</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>

</nav>
  <div class="site-search">
    <div class="popup search-popup">
    <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocorrect="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result"></div>

</div>
<div class="search-pop-overlay"></div>

  </div>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/03/04/article-1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="http://i16.yd166.com/file/img/0w167560051u3518757329t26.jpg">
      <meta itemprop="name" content="R">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="想吃煎饼果子">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          《GraphRel：Modeling Text as Relational Graphs for Joint Entity and Relation Extraction》阅读记录
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-03-04 18:17:10 / 修改时间：20:23:15" itemprop="dateCreated datePublished" datetime="2020-03-04T18:17:10+08:00">2020-03-04</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">笔记</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="abstract"><a class="markdownIt-Anchor" href="#abstract"></a> Abstract</h1>
<p>本文提出了一种端到端的关系抽取模型GraphRel，它使用GCN来共同学习命名实体和关系。与之前的基线相比，我们通过关系加权GCN来考虑命名实体和关系之间的交互，以更好地提取关系。线性结构和依赖结构都用于提取文本的序列和区域特征，并且完整的单词图还用于提取文本中所有单词对的隐含特征。使用基于图的方法，重叠关系的预测比先前的序列方法有了很大的改进。我们在两个公共数据集上评估GraphRel。结果表明，GraphRel在保持高精度的同时，显著提高了查全率。另外，GraphRel的性能比以前的工作高出3.2%和5.8%(F1 Score)，实现了关系抽取的新SOTA。</p>
<a id="more"></a>
<h1 id="1%20Introduction"><a name="t2"></a><a name="t2"></a>1 Introduction</h1>
<p style="text-indent:33px;">提取具有语义关系的实体对，即三元组（如BarackObama，PresidentOf，UnitedStates）是信息提取的中心任务，需要从非结构化文本自动构建知识。 三个关键方面仍需要在统一框架中进行全面处理：</p>
<ul><li>实体识别和关系提取的端到端联合建模；</li>
	<li>对重叠关系的预测，即共同提及的关系；</li>
	<li>考虑关系之间的相互作用，尤其是重叠关系。</li>
</ul><p style="text-indent:33px;">传统上，①pipeline使用命名实体识别器提取实体，然后预测每对提取的实体之间的关系；②建立了联合实体识别和关系抽取模型，以利用这两个任务之间的密切交互。联合建模这些复杂的方法是基于特征的结构化学习系统，严重依赖于特征工程。</p>
<p style="text-indent:33px;">随着深度神经网络的成功，基于神经网络的自动特征学习方法已被应用到关系提取中。 这些方法在两个提及实体之间的单词序列上 ①使用CNN，LSTM或Tree-LSTM，②两个实体之间的最短依赖路径或 ③跨越两个实体的minimal constituency sub-tree 来编码每对实体的相关信息 。 但这些方法不是实体和关系的端到端联合建模。假设给出了实体，并且在实际使用中需要命名实体识别器时，预期其性能会显着下降。</p>
<p style="text-indent:33px;">关系提取的另一个挑战是如何考虑关系之间的相互作用，这对于重叠关系——即共享共同实体的关系特别重要。例如，①EntityPairOverlap，从（BarackObama, Governance, UnitedStates）推断出（BarackObama, PresidentOf, UnitedStates）。另一个案例是，从（BarackObama, LiveIn, WhiteHouse）和（WhiteHouse, PresidentialPalace, UnitedStates）推断出刚才的三元组，其中后两个三元组被认为具有②SingleEntityOverlap。尽管这种交互作用在知识库完成中很常见，但无论是通过直接推理还是通过间接证明进行这种交互，对于输入中不存在实体的联合实体识别和关系提取模型而言尤其困难。尽管Zheng等人提出了一种基于LSTM序列标签器的强大的实体与关系的神经端到端联合模型，但他们必须完全放弃重叠关系。</p>
<p style="text-indent:33px;">在本文中，我们提出了GraphRel，这是一种用于实体识别和关系提取的神经端到端联合模型，它是第一个处理关系提取中所有三个关键部分的模型。 GraphRel通过堆叠Bi-LSTM句子编码器和GCN依赖树编码器来学习自动提取每个单词的隐藏特征。 然后GraphRel标记实体提及单词并预测连接提及的关系三元组，这是第一阶段预测。</p>
<p style="text-indent:33px;">为了在考虑到三元组之间的相互作用的情况下进行预测，我们在GraphRel第二阶段添加了一个新颖的关系加权GCN。 第一阶段GraphRel接收到实体损失和关系损失，沿着依赖关系链接提取节点隐藏特征，同时建立具有关系加权边的新全连接图。 然后，通过对<strong>中间图</strong>进行操作，第二阶段GCN在最终分类每个边之前有效地考虑实体之间的相互作用以及（可能重叠的）关系。</p>
<p><strong>GraphRel：</strong></p>
<ul><li>考虑了线性和依赖结构，以及文本中所有单词对之间的隐含特征；</li>
	<li>对实体和关系进行端到端的联合建模，同时考虑所有单词对进行预测；</li>
	<li>仔细考虑实体与关系之间的相互作用。</li>
</ul><p style="text-indent:33px;">在两个公共关系提取数据集上评估该方法：NYT和WebNLG。 实验结果表明，GraphRel与以前的工作相比大大改善了重叠关系，并且在两个数据集上都达到了SOTA。</p>
<h1 id="2%20Related%20Work"><a name="t3"></a><a name="t3"></a>2 Related Work</h1>
<p style="text-indent:33px;">模型的BiLSTM-GCN编码器部分类似于Miwa和Bansal（2016）提出的BiLSTM-TreeLSTM模型，因为它们还在序列顶部堆叠了依赖树，以共同对实体和关系进行建模。BiLSTM-TreeLSTM模型在每个句子上使用Bi-LSTM进行自动特征学习，并且所提取的隐藏特征由顺序实体tagger和最短依赖路径关系classifier共享。 但是，在引入共享参数以进行联合实体识别和关系提取时，它们仍必须通过pipeline传递tagger预测的实体提及，以形成关系分类的实体对。</p>
<p style="text-indent:33px;">Zheng等人（2018）没有像以前的工作那样尝试对每个提及对进行分类，而是将关系提取构造为与实体识别一样的序列标记问题。 这可以在Bi-LSTM编码器的顶部通过LSTM解码器对关系提取进行建模。 但是，尽管在NYT数据集上显示出令人鼓舞的结果，但它们的优势却来自于关注孤立的关系并完全放弃了重叠关系。 相比之下，<strong>GraphRel在端到端并共同建模实体识别的同时，可以处理所有类型的关系</strong>。</p>
<p style="text-indent:33px;">Zeng等人随后提出了一种用于关系提取的端对端序列到序列模型。 它们通过Bi-LSTM编码每个句子，并使用最后的编码器隐藏状态初始化一个（OneDecoder）或多个（MultiDecoder）LSTM，以动态解码关系三元组。 解码时，通过选择一个关系并从句子中复制两个单词来生成三元组。seq2seq设置部分处理三元组之间的交互。然而，在生成新三元组时，通过考虑先前生成的具有强制线性顺序的三元组，只能单向捕获关系之间的相互作用。相反，在本文中，<strong>通过在LSTM-GCN编码器上应用第二阶段GCN，提出在具有自动学习链接的字图上传播实体和关系信息。</strong></p>
<p style="text-indent:33px;">最近，在许多自然语言处理（NLP）任务中都使用了GCN的依赖关系结构。 Marcheggiani 和 Titov 将GCN应用于单词序列以进行语义角色标记。 Liu等人通过GCN对长文档进行编码以执行文本匹配。 Cetoli等人结合RNN和GCN来识别命名实体。 关于考虑单词序列的依存关系进行关系提取的工作也有一些工作。 在提出的GrpahRel中，<strong>不仅堆叠Bi-LSTM和GCN来考虑线性结构和依赖结构，而且采用第二阶段关系加权GCN来进一步建模实体与关系之间的相互作用。</strong></p>
<h1 id="3%20Review%20of%20GCN"><a name="t4"></a><a name="t4"></a>3 Review of GCN</h1>
<p style="text-indent:33px;">作为卷积神经网络（CNN），图卷积网络（GCN）卷积相邻节点的特征，并将节点的信息传播到其最近的邻居。如图1所示，通过堆叠GCN层，GCN可以提取每个节点的区域特征。</p>
<p style="text-align:center;"><img alt="" class="has" height="226" src="https://img-blog.csdnimg.cn/20191022211619599.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTMxMTgx,size_16,color_FFFFFF,t_70" width="400"></p>
<p>GCN层通过使用以下等式考虑相邻节点的特征来检索新的节点特征：</p>
<p style="text-align:center;"><img alt="" class="has" height="120" src="https://img-blog.csdnimg.cn/2019102221192439.png" width="450"></p>
<p>其中&nbsp;<img alt="\mu" src="https://private.codecogs.com/gif.latex?%5Cmu">&nbsp;是目标节点，<img alt="N(u)" class="mathcode" src="https://private.codecogs.com/gif.latex?N%28u%29">&nbsp;表示&nbsp;<img alt="\mu" src="https://private.codecogs.com/gif.latex?%5Cmu">&nbsp;的邻域，包括&nbsp;<img alt="\mu" src="https://private.codecogs.com/gif.latex?%5Cmu">&nbsp;本身； <img alt="h_{v}^{l}" class="mathcode" src="https://private.codecogs.com/gif.latex?h_%7Bv%7D%5E%7Bl%7D">&nbsp;表示节点&nbsp;<img alt="v" class="mathcode" src="https://private.codecogs.com/gif.latex?v"> 在第&nbsp;<img alt="l" class="mathcode" src="https://private.codecogs.com/gif.latex?l">&nbsp;层的隐藏特征； &nbsp;<img alt="W" class="mathcode" src="https://private.codecogs.com/gif.latex?W">&nbsp;和&nbsp;<img alt="b" class="mathcode" src="https://private.codecogs.com/gif.latex?b">&nbsp;是可学习的权重，将节点的特征映射到图中的相邻节点；<img alt="h\in \mathbb{R}^{f}, W\in \mathbb{R}^{f\times f}, b\in \mathbb{R}^{f}" class="mathcode" src="https://private.codecogs.com/gif.latex?h%5Cin%20%5Cmathbb%7BR%7D%5E%7Bf%7D%2C%20W%5Cin%20%5Cmathbb%7BR%7D%5E%7Bf%5Ctimes%20f%7D%2C%20b%5Cin%20%5Cmathbb%7BR%7D%5E%7Bf%7D"> ,其中&nbsp;<img alt="f" class="mathcode" src="https://private.codecogs.com/gif.latex?f">&nbsp;是特征尺寸。</p>
<h1 id="4%20Methodology"><a name="t5"></a><a name="t5"></a>4 Methodology</h1>
<p style="text-indent:33px;">所提出的 GraphRel 包含2个阶段的预测的总体架构图下图所示。<strong>第1阶段</strong>，采用bi-RNN和GCN来提取顺序和位置依赖词特征。 给定单词特征，预测每个单词对与所有单词的实体之间的关系。<strong>第2阶段</strong>，为第一阶段预测的每个关系建立完整的关系图，并在每个图上应用GCN以整合每个关系的信息，并进一步考虑实体与关系之间的相互作用。</p>
<p><img alt="" class="has" height="535" src="https://img-blog.csdnimg.cn/20191023092533484.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTMxMTgx,size_16,color_FFFFFF,t_70" width="1200"></p>
<h2 id="4.1%C2%A0%201st-phase%20Prediction"><a name="t6"></a><a name="t6"></a>4.1&nbsp; 1st-phase Prediction</h2>
<p style="text-indent:33px;">为充分考虑文本特征的顺序和位置依赖性，首先应用双向RNN提取顺序特征，然后使用双向GCN进一步提取位置依赖性特征。 然后，基于提取的单词特征，预测每个单词对与单词实体之间的关系。</p>
<h3 id="4.1.1%20Bi-LSTM"><a name="t7"></a><a name="t7"></a>4.1.1 Bi-LSTM</h3>
<p style="text-indent:33px;">使用LSTM作为双RNN单元，&nbsp;对于每个单词，将单词嵌入和词性（POS）嵌入组合为初始特征，其中&nbsp;<img alt="h_{u}^{0}" class="mathcode" src="https://private.codecogs.com/gif.latex?h_%7Bu%7D%5E%7B0%7D">&nbsp;代表单词&nbsp;<img alt="u" class="mathcode" src="https://private.codecogs.com/gif.latex?u">&nbsp;的初始特征，而&nbsp;<img alt="Word(u)" class="mathcode" src="https://private.codecogs.com/gif.latex?Word%28u%29">&nbsp;和&nbsp;<img alt="Pos(u)" class="mathcode" src="https://private.codecogs.com/gif.latex?Pos%28u%29">&nbsp;分别是单词&nbsp;<img alt="u" src="https://private.codecogs.com/gif.latex?u">&nbsp;的单词嵌入和POS嵌入。 使用GloVe的预训练词嵌入，并随机初始化POS嵌入以使用整个GraphRel 进行训练。</p>
<p style="text-align:center;"><img alt="" class="has" height="87" src="https://img-blog.csdnimg.cn/20191023094653902.png" width="500"></p>
<h3 id="4.1.2%20Bi-GCN"><a name="t8"></a><a name="t8"></a>4.1.2 Bi-GCN</h3>
<p style="text-indent:33px;">由于原始输入语句是一个序列并且没有固有的图结构可言，因此使用denpendency parse为输入语句创建一个依赖树。 将依赖树用作输入句子的邻接矩阵，并使用GCN提取位置依赖特征。原始GCN是为无向图设计的。，为了同时考虑单词的输入输出特征，将Bi-GCN规定为如下表达式：</p>
<p style="text-align:center;"><img alt="" class="has" height="321" src="https://img-blog.csdnimg.cn/20191023110123301.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTMxMTgx,size_16,color_FFFFFF,t_70" width="500"></p>
<p>其中&nbsp;<img alt="h_{u}^{l}" class="mathcode" src="https://private.codecogs.com/gif.latex?h_%7Bu%7D%5E%7Bl%7D">&nbsp;代表单词&nbsp;<img alt="u" class="mathcode" src="https://private.codecogs.com/gif.latex?u">&nbsp;在&nbsp;<img alt="l" src="https://private.codecogs.com/gif.latex?l">&nbsp;层中&nbsp;的隐藏特征，<img alt="\overrightarrow{N}(u)" class="mathcode" src="https://private.codecogs.com/gif.latex?%5Coverrightarrow%7BN%7D%28u%29">&nbsp;包括从单词&nbsp;<img alt="u" src="https://private.codecogs.com/gif.latex?u">&nbsp;输出的所有单词，<img alt="\overleftarrow{N}(u)" class="mathcode" src="https://private.codecogs.com/gif.latex?%5Coverleftarrow%7BN%7D%28u%29">&nbsp;包含从单词&nbsp;<img alt="u" src="https://private.codecogs.com/gif.latex?u">&nbsp;输入的所有单词，都包括单词&nbsp;<img alt="u" src="https://private.codecogs.com/gif.latex?u">&nbsp;本身。 <img alt="W" class="mathcode" src="https://private.codecogs.com/gif.latex?W">&nbsp;和 <img alt="b" class="mathcode" src="https://private.codecogs.com/gif.latex?b">&nbsp;都是可学习的卷积权重。<img alt="\overrightarrow{W}, \overrightarrow{b}, \overleftarrow{W},\overleftarrow{b}" class="mathcode" src="https://private.codecogs.com/gif.latex?%5Coverrightarrow%7BW%7D%2C%20%5Coverrightarrow%7Bb%7D%2C%20%5Coverleftarrow%7BW%7D%2C%5Coverleftarrow%7Bb%7D">&nbsp;分别代表输出权重和输入权重，输出和输入单词特征连接为最终单词特征。</p>
<h3 id="4.1.3%20Extraction%20of%20Entities%20and%20Relations"><a name="t9"></a><a name="t9"></a>4.1.3 Extraction of Entities and Relations</h3>
<p style="text-indent:33px;">利用从 Bi-RNN 和 Bi-GCN 提取的单词特征，预测单词实体并提取每个单词对的关系。 对于单词实体，根据1-layer LSTM上的单词特征预测所有单词，并应用分类损失（称为&nbsp;<img alt="eloss_{1p}" class="mathcode" src="https://private.codecogs.com/gif.latex?eloss_%7B1p%7D">）来训练它们。 <strong>对于关系提取，删除依赖边并对所有单词对进行预测</strong>。 对于每个关系r，学习权重矩阵&nbsp;<img alt="W_{r}^{1}, W_{r}^{2}, W_{r}^{3}" class="mathcode" src="https://private.codecogs.com/gif.latex?W_%7Br%7D%5E%7B1%7D%2C%20W_%7Br%7D%5E%7B2%7D%2C%20W_%7Br%7D%5E%7B3%7D">&nbsp;并计算关系趋势得分S为</p>
<p style="text-align:center;"><img alt="" class="has" height="79" src="https://img-blog.csdnimg.cn/20191023112951951.png" width="500"></p>
<p>其中&nbsp;<img alt="S_{(\omega 1, r, \omega 2)}" class="mathcode" src="https://private.codecogs.com/gif.latex?S_%7B%28%5Comega%201%2C%20r%2C%20%5Comega%202%29%7D">&nbsp;表示关系&nbsp;<img alt="r" class="mathcode" src="https://private.codecogs.com/gif.latex?r">&nbsp;下的&nbsp;<img alt="(\omega 1, \omega 2)" src="https://private.codecogs.com/gif.latex?%28%5Comega%201%2C%20%5Comega%202%29">&nbsp;的关系趋势得分，而&nbsp;<img alt="(\omega 1, \omega 2)" src="https://private.codecogs.com/gif.latex?%28%5Comega%201%2C%20%5Comega%202%29"> 表示单词对。 请注意，<img alt="S_{(\omega 1, r, \omega 2))}" src="https://private.codecogs.com/gif.latex?S_%7B%28%5Comega%201%2C%20r%2C%20%5Comega%202%29%29%7D">&nbsp;应该不同于&nbsp;<img alt="S_{(\omega 2, r, \omega 1))}" class="mathcode" src="https://private.codecogs.com/gif.latex?S_%7B%28%5Comega%202%2C%20r%2C%20%5Comega%201%29%29%7D">。 对于单词对&nbsp;<img alt="(\omega 1, \omega 2)" src="https://private.codecogs.com/gif.latex?%28%5Comega%201%2C%20%5Comega%202%29">&nbsp;，计算该单词对的所有相关趋势得分，包括非相关性，并将其表示为&nbsp;<img alt="S_{(\omega 1, null, \omega 2))}" class="mathcode" src="https://private.codecogs.com/gif.latex?S_%7B%28%5Comega%201%2C%20null%2C%20%5Comega%202%29%29%7D">&nbsp;。 将 softmax 函数应用于&nbsp;<img alt="S_{(\omega 1, r, \omega 2))}" src="https://private.codecogs.com/gif.latex?S_%7B%28%5Comega%201%2C%20r%2C%20%5Comega%202%29%29%7D">&nbsp;，得出<img alt="P_{r}_{(\omega 1, \omega 2))}" src="https://private.codecogs.com/gif.latex?P_%7Br%7D_%7B%28%5Comega%201%2C%20%5Comega%202%29%29%7D">&nbsp;，它表示每个关系&nbsp;<img alt="r" src="https://private.codecogs.com/gif.latex?r">&nbsp;对于&nbsp;<img alt="(\omega 1, \omega 2)" src="https://private.codecogs.com/gif.latex?%28%5Comega%201%2C%20%5Comega%202%29"> 的概率。</p>
<p style="text-indent:33px;">由于提取每个单词对的关系，因此设计中不包含三元组数量限制。 通过调查每个单词对的关系，GraphRel识别出尽可能多的关系。 利用<img alt="P_{r}_{(\omega 1, \omega 2))}" src="https://private.codecogs.com/gif.latex?P_%7Br%7D_%7B%28%5Comega%201%2C%20%5Comega%202%29%29%7D">，计算出分类损失的关系，记为&nbsp;<img alt="rloss_{1p}" class="mathcode" src="https://private.codecogs.com/gif.latex?rloss_%7B1p%7D">。 请注意，尽管&nbsp;<img alt="eloss_{1p}" src="https://private.codecogs.com/gif.latex?eloss_%7B1p%7D">&nbsp;和&nbsp;<img alt="rloss_{1p}" src="https://private.codecogs.com/gif.latex?rloss_%7B1p%7D">都不会被用作最终预测，但它们对于训练第一阶段GraphRel的有益辅助损失。</p>
<h2 id="4.2%C2%A0%202nd-phase%20Prediction"><a name="t10"></a><a name="t10"></a>4.2&nbsp; 2nd-phase Prediction</h2>
<p style="text-indent:33px;">第一阶段中没有考虑提取的实体和关系之间的联系，<strong>为了考虑命名实体和关系之间的影响，并考虑文本所有词对之间的隐含特征</strong>，本文在第二阶段提出了一种新的<strong>关系加权GCN</strong>进行进一步提取。</p>
<h3 id="4.2.1%C2%A0%20Relation-weighted%20Graph"><a name="t11"></a><a name="t11"></a>4.2.1&nbsp; Relation-weighted Graph</h3>
<p style="text-indent:33px;">经过第一阶段的预测，为每个关系&nbsp;<img alt="r" src="https://private.codecogs.com/gif.latex?r">&nbsp;构造了完整的关系加权图，其中&nbsp;<img alt="(\omega 1, \omega 2)" src="https://private.codecogs.com/gif.latex?%28%5Comega%201%2C%20%5Comega%202%29">&nbsp;的边权为&nbsp;<img alt="P_{r}_{(\omega 1, \omega 2)}" class="mathcode" src="https://private.codecogs.com/gif.latex?P_%7Br%7D_%7B%28%5Comega%201%2C%20%5Comega%202%29%7D">，如下图所示。</p>
<p style="text-align:center;"><img alt="" class="has" height="343" src="https://img-blog.csdnimg.cn/20191023193638111.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTMxMTgx,size_16,color_FFFFFF,t_70" width="500"></p>
<p>然后，第二阶段在每个关系图上采用Bi-GCN，考虑不同关系的不同影响程度并聚合作为<strong>综合词特征</strong>。 该过程可以表示为</p>
<p style="text-align:center;"><img alt="" class="has" height="113" src="https://img-blog.csdnimg.cn/20191023194320558.png" width="450"></p>
<p>其中<img alt="P_{r}_{(u, v)}" class="mathcode" src="https://private.codecogs.com/gif.latex?P_%7Br%7D_%7B%28u%2C%20v%29%7D">&nbsp;表示边权重（关系 <img alt="r" class="mathcode" src="https://private.codecogs.com/gif.latex?r">&nbsp;下单词&nbsp;<img alt="u" class="mathcode" src="https://private.codecogs.com/gif.latex?u">&nbsp;到单词 <img alt="v" class="mathcode" src="https://private.codecogs.com/gif.latex?v">&nbsp;的概率）。 <img alt="W_{r}" class="mathcode" src="https://private.codecogs.com/gif.latex?W_%7Br%7D">&nbsp;和 <img alt="b_{r}" class="mathcode" src="https://private.codecogs.com/gif.latex?b_%7Br%7D">&nbsp;表示关系 <img alt="r" class="mathcode" src="https://private.codecogs.com/gif.latex?r">&nbsp;下的GCN权重。 <img alt="V" class="mathcode" src="https://private.codecogs.com/gif.latex?V">&nbsp;包含所有单词，<img alt="R" class="mathcode" src="https://private.codecogs.com/gif.latex?R">&nbsp;包含所有关系。 请注意，完整的Bi-GCN还将输入和输出情况都考虑在内。 第二阶段的Bi-GCN进一步考虑了关系加权传播，并为每个单词提取了更充分的特征。用来自二阶段新提取的单词特征，再次执行命名实体和关系分类以实现更可靠的关系预测，损失为&nbsp;<img alt="eloss_{2p}" class="mathcode" src="https://private.codecogs.com/gif.latex?eloss_%7B2p%7D">&nbsp;和&nbsp;<img alt="rloss_{2p}" class="mathcode" src="https://private.codecogs.com/gif.latex?rloss_%7B2p%7D">。</p>
<h2 id="4.3%C2%A0%20Training%20Detail"><a name="t12"></a><a name="t12"></a>4.3&nbsp; Training Detail</h2>
<p style="text-indent:33px;">在GraphRel中使用两种损失：<strong>实体损失和关系损失</strong>，两者都属于类别损失，在训练过程中使用<strong>交叉熵</strong>作为分类损失函数。 实体损失使用BIESO方法来标注真实标签，&nbsp;<img alt="eloss_{1p}" class="mathcode" src="https://private.codecogs.com/gif.latex?eloss_%7B1p%7D">&nbsp;和&nbsp;<img alt="eloss_{2p}" class="mathcode" src="https://private.codecogs.com/gif.latex?eloss_%7B2p%7D">&nbsp;的真实实体标签相同。关系损失为每个单词对&nbsp;<img alt="(\omega 1, \omega 2)" src="https://private.codecogs.com/gif.latex?%28%5Comega%201%2C%20%5Comega%202%29">&nbsp;输入一个one-hot编码的关系向量作为&nbsp;<img alt="P_{r}_{(\omega 1, \omega 2)}" class="mathcode" src="https://private.codecogs.com/gif.latex?P_%7Br%7D_%7B%28%5Comega%201%2C%20%5Comega%202%29%7D">&nbsp;的真实数据。 由于基于单词对预测关系，真实数据同样应基于单词对。 也就是说，单词United对于单词Barack和单词Obama都有HasPresident的关系，单词States也是如此。基于单词对的关系表示为GraphRel提供了学习提取关系所需的信息，<img alt="rloss_{1p}" class="mathcode" src="https://private.codecogs.com/gif.latex?rloss_%7B1p%7D">&nbsp;和&nbsp;<img alt="rloss_{2p}" class="mathcode" src="https://private.codecogs.com/gif.latex?rloss_%7B2p%7D">&nbsp;的真实数据关系向量相同。</p>
<p style="text-indent:33px;">对于eloss和rloss，为类内实体或关系项添加额外的double-weight。总损失为所有实体损失和关系损失的总和：其中 <img alt="\alpha" class="mathcode" src="https://private.codecogs.com/gif.latex?%5Calpha">&nbsp;是第一阶段和第二阶段的损失之间的权重。将 <img alt="loss_{all}" class="mathcode" src="https://private.codecogs.com/gif.latex?loss_%7Ball%7D">&nbsp;降到最低，并以端到端的方式训练整个GraphRel。</p>
<p style="text-align:center;"><img alt="" class="has" height="70" src="https://img-blog.csdnimg.cn/20191023202501130.png" width="550"></p>
<h2 id="4.4%C2%A0%20Inference"><a name="t13"></a><a name="t13"></a>4.4&nbsp; Inference</h2>
<p style="text-indent:33px;">beseline预测方法是head prediction（没明白怎么理解），当且仅当 BarackObama, UnitedStates 都被识别为实体且 PresidentOf 为<img alt="P_{(Obama, States)}" class="mathcode" src="https://private.codecogs.com/gif.latex?P_%7B%28Obama%2C%20States%29%7D">&nbsp;的最大概率时，才会提取诸如（BarackObama，PresidentOf，United States）的关系三元组。另一种可能更稳定的提取方法是平均预测，其中考虑实体提及对之间的所有单词对，选择具有最大平均概率的关系。第三种是阈值预测方法，其中实体对的所有单词对仍会考虑在内，但以独立的方式进行。例如，如果4个分布中的2个具有 PresidentOf 作为最可能的类别，则仅当2/4 = 50％&gt;θ 时才提取三元组（BarackObama，PresidentOf，UnitedStates），其中 θ 是自由阈值参数。这样，用户可以选择自己喜欢的精度并通过调整 θ 进行权衡，如果未指定 θ=0 。</p>
<h1 id="5%C2%A0%20Experiments" style="text-indent:0px;"><a name="t14"></a><a name="t14"></a>5&nbsp; Experiments</h1>
<p style="text-indent:33px;">这一部分给出了GraphRel的实验结果。首先是实施细节、数据集和比较的baseline，然后展示两个数据集的定量结果，进行了详细的分析，并对不同类别的命名实体进行了分类，最后通过一个案例说明第二阶段的改进效果。</p>
<h2 id="5.1%20Experimental%20Settings" style="text-indent:0px;"><a name="t15"></a><a name="t15"></a>5.1 Experimental Settings</h2>
<p style="text-indent:33px;">实现中，选择预训练的GloVe（300d）作为固定的单词嵌入，然后将单词嵌入与可训练的POS嵌入（15d）连接起来，作为每个单词的最终输入嵌入，从spaCy检索每个单词的POS标签和整个句子的依存关系树。在第一阶段使用具有256个单位的Bi-LSTM和具有256个特征的2层Bi-GCN。 对于第二阶段，关系加权的Bi-GCN为1层，特征尺寸为256。在训练期间，将LSTM辍学率设置为0.5，学习率设置为0.0008，损失权重α设置为 3，使用Adam优化器训练GraphRel，并在PyTorch下实现它。</p>
<h3 id="5.1.1%C2%A0%20Datasets" style="text-indent:0px;"><a name="t16"></a><a name="t16"></a>5.1.1&nbsp; Datasets</h3>
<p style="text-indent:33px;">使用NYT和WebNLG数据集来评估所提出的方法。 正如 NovelTagging 和 MultiDecoder 一样，对于NYT过滤的句子超过100个单词；对于WebNLG，在实验中的每个实例中仅使用第一个句子。 表2中描述了NYT和WebNLG的统计信息，将关系三元组分为三类：正常，EntityPairOverlap（EPO）和SingleEntityOverlap（SEO），&nbsp;表2还显示了每个类别的总数。由于一个实体属于几个不同的关系，因此EntityPairOverlap和SingleEntityOverlap难度更大。 会在详细分析中讨论不同类别的结果。</p>
<h2 id="5.2%C2%A0%20Baseline%20and%20Evaluation%20Metrics" style="text-indent:0px;"><a name="t17"></a><a name="t17"></a>5.2&nbsp; Baseline and Evaluation Metrics</h2>
<p style="text-indent:33px;">将GraphRel与两个baseline进行了比较：NovelTagging和MultiDecoder。 NovelTagging是一种序列标记器，可预测每个句子单词的实体和关系；MultiDecoder是一种最新的方法，将关系提取视为seq-seq问题，并使用动态解码器提取关系三元组。 这两个baseline的结果直接来自原始论文。 作为两个baselien，采用了标准的F1分数来评估结果。 当且仅当两个对应实体的关系和首部与真实数据相同时，才能将预测的三元组视为正确的。</p>
<p style="text-align:center;"><img alt="" class="has" height="307" src="https://img-blog.csdnimg.cn/20191023215945553.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTMxMTgx,size_16,color_FFFFFF,t_70" width="500"></p>
<h2 id="5.3%C2%A0%20Quantitative%20Results" style="text-indent:0px;"><a name="t18"></a><a name="t18"></a>5.3&nbsp; Quantitative Results</h2>
<p style="text-indent:33px;">表1列出了NYT和WebNLG数据集的NovelTagging，MultiDecoder和GraphRel的精确率，召回率和F1得分。 MultiDecoder的原始论文中提出的OneDecoder仅使用单个解码器来提取关系三元组。 <img alt="GraphRel_{1p}" class="mathcode" src="https://private.codecogs.com/gif.latex?GraphRel_%7B1p%7D">&nbsp;是提出的方法，但仅在第一阶段，而GraphRel2p是完整版本，可预测第二阶段之后的关系和实体。 对于NYT数据集，<img alt="GraphRel_{1-hop}" class="mathcode" src="https://private.codecogs.com/gif.latex?GraphRel_%7B1-hop%7D">&nbsp;在F1方面的表现优于NovelTagging 18.0％，OneDecoder 4.0％和MultiDecoder 1.3％。 由于&nbsp;<img alt="GraphRel_{1-hop}" class="mathcode" src="https://private.codecogs.com/gif.latex?GraphRel_%7B1-hop%7D">&nbsp;同时具有顺序和位置依赖词特征，因此它在精确率和查全率方面均表现更好，因此F1得分更高。 与第二阶段的关系加权GCN相比，考虑名称实体与关系之间相互作用的&nbsp;<img alt="GraphRel_{2p}" class="mathcode" src="https://private.codecogs.com/gif.latex?GraphRel_%7B2p%7D">&nbsp;与&nbsp;<img alt="GraphRel_{1p}" class="mathcode" src="https://private.codecogs.com/gif.latex?GraphRel_%7B1p%7D">&nbsp;相比，进一步超过了MultiDecoder 3.2％，并且改进了1.9％。</p>
<p style="text-align:center;"><img alt="" class="has" height="338" src="https://img-blog.csdnimg.cn/20191023215923980.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTMxMTgx,size_16,color_FFFFFF,t_70" width="1000"></p>
<p style="text-indent:33px;">在WebNLG数据集上可以找到类似的结果：GraphRel1p的基准F1 Score优于MultiDecoder 3.6％，而GraphRel2p 比 GraphRel1p进一步提高了2.2％。 根据NYT和WebNLG的结果，GCN的位置依赖关系特征和第二阶段预测都可以在精确率，召回率和F1 Score方面帮助进行关系预测。 NovelTagging和MultiDecoder都使用顺序体系结构。 由于NovelTagging假定实体属于单一关系，因此精度很高，但召回率很低。 MultiDecoder使用动态解码器生成关系三元组。 由于RNN结构的先天限制（后信息需要前信息发生），它可以生成的三元组的数量受到限制。 但是GraphRel在预测每个单词对的关系时不受此限制。GraphRel是最平衡的方法，同时保持了高精确率和高召回率，并有更高的F1 Score。</p>
<h2 id="5.4%C2%A0%20Detailed%20Analysis"><a name="t19"></a><a name="t19"></a>5.4&nbsp; Detailed Analysis</h2>
<p style="text-indent:33px;">为了进一步分析提出的GraphRel，给出在不同类型的三元组、不同的推理方法、改进的命名实体识别以及使用不同GCN层数的情况下的分析结果。</p>
<h3 id="5.4.1%C2%A0%20Different%20Types%20of%20Triplets" style="text-indent:0px;"><a name="t20"></a><a name="t20"></a>5.4.1&nbsp; Different Types of Triplets</h3>
<p style="text-indent:33px;">首先调查不同实体类别下的结果。图4给出了NYT和WebNLG数据集的结果。对于GraphRel，当预测所有单词对的关系时，所有单词都可以与其他单词具有关系：因此<strong>实体重叠</strong>不是问题。尽管MultiDecoder尝试使用动态解码器，但结果表明GraphRel在所有实体类别中都超过了它们。例如，在WebNLG数据集上，GraphRel1p在MultiClass上的表现优于Normal3.5％，EPO类2.9％和SEO类3.4％。 GraphRel2p进一步改进了每个类的GraphRel1p。还比较了给定的句子中不同数量的三元组的结果，如图5所示。x轴表示句子中的1、2、3、4或5个以上的三元组。由于使用了单个解码器，所以OneDecoder对于单个三元组的性能很好，但是对于句子中更多的三元组，性能会急剧下降。与针对不同实体类别的实验一样，GraphRel1p和GraphRel2p在句子中的所有三元组数目下均优于baseline。 GraphRel1p在一个句子中多于5个三元组得分超过MultiDecoder7.5％，而GraphRel2p在NYT上进一步超过MultiDecoder 11.1％。</p>
<p><img alt="" class="has" height="512" src="https://img-blog.csdnimg.cn/2019102322341628.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTMxMTgx,size_16,color_FFFFFF,t_70" width="1200"></p>
<p><img alt="" class="has" height="503" src="https://img-blog.csdnimg.cn/20191023223442193.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTMxMTgx,size_16,color_FFFFFF,t_70" width="1200"></p>
<h3 id="5.4.2%C2%A0%20Inference%20Methods"><a name="t21"></a><a name="t21"></a>5.4.2&nbsp; Inference Methods</h3>
<p style="text-indent:33px;">比较两种baseline方法，即 head 和 average，以及在不同θ下的阈值法。 图6显示了将其应用于NYT和WebNLG上的GraphRel2p的结果。 可以看出，阈值法有效地调整了不同θ选择下精确率和召回率之间的平衡。 通过将阈值从 θ=0.8 降低到 θ=0，NYT和WebNLG的召回率分别显着提高了1.8％和1.4％，而精确率仅略微降低了0.6％。 阈值法的有效性致使在两个数据集上均达到最佳性能，超过了其他两种方法。</p>
<p style="text-align:center;"><img alt="" class="has" height="474" src="https://img-blog.csdnimg.cn/2019102409370847.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTMxMTgx,size_16,color_FFFFFF,t_70" width="700"></p>
<h3 style="text-indent:0px;"><a name="t22"></a><a name="t22"></a>5.4.3&nbsp; Improvement over Entity Recognition and Different Numbers of GCN Layer</h3>
<p style="text-indent:33px;">根据表4，对于NYT和WebNLG上的实体识别，GraphRel2p可以超过第一阶段0.4％和2.8％。 第二阶段的关系加权的GCN不仅对关系提取有效，而且对命名实体识别也有效。为了确认2层加1层的最佳设置，在第一阶段和第二阶段中使用不同数量的GCN层进行测试。表5给出了将3个GCN层用于第一阶段并将2个关系加权GCN层用于第二阶段的实验结果，表明更多的GCN层不能带来更好的预测，而（2,1）层应该是最适合关系提取任务的设置。&nbsp;</p>
<h1 style="text-indent:0px;"><a name="t23"></a><a name="t23"></a>5.5&nbsp; Case Study</h1>
<p style="text-indent:33px;">表3显示了GraphRel的案例研究。第一个句子很简单，并且GraphRel1p和GraphRel2p都可以准确提取。对于第二种情况，尽管不属于命名实体，但它应包含Italy的隐藏语义。 因此第二阶段可以进一步预测 <em>A.S. Gubbio 1910 grounds in Italy</em>。第三种情况是SEO类，其中GraphRel1p发现Asam pedas与Asam padeh相同，因此后者也应位于马来半岛并来自马来西亚。</p>
<p style="text-align:center;"><img alt="" class="has" height="427" src="https://img-blog.csdnimg.cn/20191024100130760.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTMxMTgx,size_16,color_FFFFFF,t_70" width="1200"></p>
<h1 style="text-indent:0px;"><a name="t24"></a><a name="t24"></a>6&nbsp; Conclusion</h1>
<p style="text-indent:33px;">本文中提出了GraphRel，这是一种基于图卷积网络（GCN）共同学习命名实体和关系的端到端关系提取模型。将RNN和GCN结合起来提取每个单词的顺序特征和位置依赖特征，也考虑了文本中所有单词对之间的隐含特征。 通过预测每个单词对的关系，解决实体重叠的问题。 此外，提出一种新颖的关系加权GCN，考虑了命名实体与关系之间的相互作用。在NYT和WebNLG数据集上评估提出的方法。 结果表明，此方法比以前的工作分别提高了3.2％和5.8％，并实现了关系提取的SOTA。</p>
<p>&nbsp;</p>
    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E8%AE%BA%E6%96%87%E8%AE%B0%E5%BD%95/" rel="tag"># 论文记录</a>
              <a href="/tags/NLP/" rel="tag"># NLP</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item"></div>
      <div class="post-nav-item">
    <a href="/2020/03/04/article-2/" rel="next" title="《Graph Neural Networks with Generated Parameters for Relation Extraction》阅读笔记">
      《Graph Neural Networks with Generated Parameters for Relation Extraction》阅读笔记 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#abstract"><span class="nav-number">1.</span> <span class="nav-text"> Abstract</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#1%20Introduction"><span class="nav-number">2.</span> <span class="nav-text">1 Introduction</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#2%20Related%20Work"><span class="nav-number">3.</span> <span class="nav-text">2 Related Work</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#3%20Review%20of%20GCN"><span class="nav-number">4.</span> <span class="nav-text">3 Review of GCN</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#4%20Methodology"><span class="nav-number">5.</span> <span class="nav-text">4 Methodology</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#4.1%C2%A0%201st-phase%20Prediction"><span class="nav-number">5.1.</span> <span class="nav-text">4.1&amp;nbsp; 1st-phase Prediction</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4.1.1%20Bi-LSTM"><span class="nav-number">5.1.1.</span> <span class="nav-text">4.1.1 Bi-LSTM</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4.1.2%20Bi-GCN"><span class="nav-number">5.1.2.</span> <span class="nav-text">4.1.2 Bi-GCN</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4.1.3%20Extraction%20of%20Entities%20and%20Relations"><span class="nav-number">5.1.3.</span> <span class="nav-text">4.1.3 Extraction of Entities and Relations</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4.2%C2%A0%202nd-phase%20Prediction"><span class="nav-number">5.2.</span> <span class="nav-text">4.2&amp;nbsp; 2nd-phase Prediction</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4.2.1%C2%A0%20Relation-weighted%20Graph"><span class="nav-number">5.2.1.</span> <span class="nav-text">4.2.1&amp;nbsp; Relation-weighted Graph</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4.3%C2%A0%20Training%20Detail"><span class="nav-number">5.3.</span> <span class="nav-text">4.3&amp;nbsp; Training Detail</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4.4%C2%A0%20Inference"><span class="nav-number">5.4.</span> <span class="nav-text">4.4&amp;nbsp; Inference</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#5%C2%A0%20Experiments"><span class="nav-number">6.</span> <span class="nav-text">5&amp;nbsp; Experiments</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#5.1%20Experimental%20Settings"><span class="nav-number">6.1.</span> <span class="nav-text">5.1 Experimental Settings</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#5.1.1%C2%A0%20Datasets"><span class="nav-number">6.1.1.</span> <span class="nav-text">5.1.1&amp;nbsp; Datasets</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5.2%C2%A0%20Baseline%20and%20Evaluation%20Metrics"><span class="nav-number">6.2.</span> <span class="nav-text">5.2&amp;nbsp; Baseline and Evaluation Metrics</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5.3%C2%A0%20Quantitative%20Results"><span class="nav-number">6.3.</span> <span class="nav-text">5.3&amp;nbsp; Quantitative Results</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5.4%C2%A0%20Detailed%20Analysis"><span class="nav-number">6.4.</span> <span class="nav-text">5.4&amp;nbsp; Detailed Analysis</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#5.4.1%C2%A0%20Different%20Types%20of%20Triplets"><span class="nav-number">6.4.1.</span> <span class="nav-text">5.4.1&amp;nbsp; Different Types of Triplets</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5.4.2%C2%A0%20Inference%20Methods"><span class="nav-number">6.4.2.</span> <span class="nav-text">5.4.2&amp;nbsp; Inference Methods</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#null"><span class="nav-number">6.4.3.</span> <span class="nav-text">5.4.3&amp;nbsp; Improvement over Entity Recognition and Different Numbers of GCN Layer</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#null"><span class="nav-number">7.</span> <span class="nav-text">5.5&amp;nbsp; Case Study</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#null"><span class="nav-number">8.</span> <span class="nav-text">6&amp;nbsp; Conclusion</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="R"
      src="http://i16.yd166.com/file/img/0w167560051u3518757329t26.jpg">
  <p class="site-author-name" itemprop="name">R</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">6</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
        <span class="site-state-item-count">1</span>
        <span class="site-state-item-name">分类</span>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">R</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v4.2.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://mist.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a> v7.7.2
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/medium-zoom@1/dist/medium-zoom.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

  

</body>
</html>
