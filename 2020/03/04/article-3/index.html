<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5"><title>《Effective Modeling of Encoder-Decoder Architecturefor Joint Entity and Relation Extraction》 | 想吃煎饼果子</title><meta name="description" content="《Effective Modeling of Encoder-Decoder Architecturefor Joint Entity and Relation Extraction》"><meta name="keywords" content="论文记录,NLP"><meta name="author" content="R"><meta name="copyright" content="R"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.ico"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="https://fonts.googleapis.com" crossorigin><link rel="preconnect" href="//busuanzi.ibruce.info"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="《Effective Modeling of Encoder-Decoder Architecturefor Joint Entity and Relation Extraction》"><meta name="twitter:description" content="《Effective Modeling of Encoder-Decoder Architecturefor Joint Entity and Relation Extraction》"><meta name="twitter:image" content="http://yoursite.com/img/avatar.png"><meta property="og:type" content="article"><meta property="og:title" content="《Effective Modeling of Encoder-Decoder Architecturefor Joint Entity and Relation Extraction》"><meta property="og:url" content="http://yoursite.com/2020/03/04/article-3/"><meta property="og:site_name" content="想吃煎饼果子"><meta property="og:description" content="《Effective Modeling of Encoder-Decoder Architecturefor Joint Entity and Relation Extraction》"><meta property="og:image" content="http://yoursite.com/img/avatar.png"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script src="https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js"></script><script>const autoChangeMode = 'false'
var t = Cookies.get("theme");
if (autoChangeMode == '1'){
const isDarkMode = window.matchMedia("(prefers-color-scheme: dark)").matches
const isLightMode = window.matchMedia("(prefers-color-scheme: light)").matches
const isNotSpecified = window.matchMedia("(prefers-color-scheme: no-preference)").matches
const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

if (t === undefined){
  if (isLightMode) activateLightMode()
  else if (isDarkMode) activateDarkMode()
  else if (isNotSpecified || hasNoSupport){
    console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
    now = new Date();
    hour = now.getHours();
    isNight = hour < 6 || hour >= 18
    isNight ? activateDarkMode() : activateLightMode()
}
} else if (t == 'light') activateLightMode()
else activateDarkMode()


} else if (autoChangeMode == '2'){
  now = new Date();
  hour = now.getHours();
  isNight = hour < 6 || hour >= 18
  if(t === undefined) isNight? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode() 
} else {
  if ( t == 'dark' ) activateDarkMode()
  else if ( t == 'light') activateLightMode()
}

function activateDarkMode(){
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null){
    document.querySelector('meta[name="theme-color"]').setAttribute('content','#000')
  }
}
function activateLightMode(){
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null){
  document.querySelector('meta[name="theme-color"]').setAttribute('content','#fff')
  }
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css"><link rel="canonical" href="http://yoursite.com/2020/03/04/article-3/"><link rel="prev" title="《Extracting Relational Facts by an End-to-End Neural Model with Copy Mechanism》记录" href="http://yoursite.com/2020/03/04/article-4/"><link rel="next" title="《Attention Guided Graph Convolutional Networks for Relation Extraction》阅读记录" href="http://yoursite.com/2020/03/04/article/"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    title: 'Snackbar.bookmark.title',
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: true,
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: false,
  fancybox: true,
  Snackbar: {"bookmark":{"title":"Snackbar.bookmark.title","message_prev":"按","message_next":"键将本页加入书签"},"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#2d3035","position":"bottom-left"},
  baiduPush: false,
  isHome: false,
  isPost: true
  
}</script><meta name="generator" content="Hexo 4.2.0"></head><body><header> <div id="page-header"><span class="pull_left" id="blog_name"><a class="blog_title" id="site-name" href="/">想吃煎饼果子</a></span><span class="toggle-menu pull_right close"><a class="site-page"><i class="fa fa-bars fa-fw" aria-hidden="true"></i></a></span><span class="pull_right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/%E4%B8%BB%E9%A1%B5/"><i class="fa-fw fa fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/%E6%97%B6%E9%97%B4%E7%BA%BF/"><i class="fa-fw fa fa-archive"></i><span> 时间线</span></a></div><div class="menus_item"><a class="site-page" href="/%E6%A0%87%E7%AD%BE/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/%E5%88%86%E7%B1%BB/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div></div></span></div></header><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">6</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">2</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">1</div></a></div></div></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="/%E4%B8%BB%E9%A1%B5/"><i class="fa-fw fa fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/%E6%97%B6%E9%97%B4%E7%BA%BF/"><i class="fa-fw fa fa-archive"></i><span> 时间线</span></a></div><div class="menus_item"><a class="site-page" href="/%E6%A0%87%E7%AD%BE/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/%E5%88%86%E7%B1%BB/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div></div></div><div id="mobile-sidebar-toc"><div class="toc_mobile_headline">目录</div><div class="sidebar-toc__content"><ol class="toc_mobile_items"><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#abstract"><span class="toc_mobile_items-number">1.</span> <span class="toc_mobile_items-text"> Abstract</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#Introduction"><span class="toc_mobile_items-number">2.</span> <span class="toc_mobile_items-text">Introduction</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#Task%20Description"><span class="toc_mobile_items-number">3.</span> <span class="toc_mobile_items-text">Task Description</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#null"><span class="toc_mobile_items-number">4.</span> <span class="toc_mobile_items-text">Encoder-Decoder Architecture</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#null"><span class="toc_mobile_items-number">5.</span> <span class="toc_mobile_items-text">Embedding Layer &amp; Encoder</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#null"><span class="toc_mobile_items-number">6.</span> <span class="toc_mobile_items-text">Word-level Decoder &amp; Copy Mechanism</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#null"><span class="toc_mobile_items-number">7.</span> <span class="toc_mobile_items-text">Pointer Network-Based Decoder</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#null"><span class="toc_mobile_items-number">8.</span> <span class="toc_mobile_items-text">Relation Tuple Extraction</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#null"><span class="toc_mobile_items-number">9.</span> <span class="toc_mobile_items-text">Attention Modeling</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#null"><span class="toc_mobile_items-number">10.</span> <span class="toc_mobile_items-text">Loss Funtion</span></a></li></ol></div></div></div><div id="body-wrap"><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true">     </i><div class="auto_open" id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#abstract"><span class="toc-number">1.</span> <span class="toc-text"> Abstract</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Introduction"><span class="toc-number">2.</span> <span class="toc-text">Introduction</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Task%20Description"><span class="toc-number">3.</span> <span class="toc-text">Task Description</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#null"><span class="toc-number">4.</span> <span class="toc-text">Encoder-Decoder Architecture</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#null"><span class="toc-number">5.</span> <span class="toc-text">Embedding Layer &amp; Encoder</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#null"><span class="toc-number">6.</span> <span class="toc-text">Word-level Decoder &amp; Copy Mechanism</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#null"><span class="toc-number">7.</span> <span class="toc-text">Pointer Network-Based Decoder</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#null"><span class="toc-number">8.</span> <span class="toc-text">Relation Tuple Extraction</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#null"><span class="toc-number">9.</span> <span class="toc-text">Attention Modeling</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#null"><span class="toc-number">10.</span> <span class="toc-text">Loss Funtion</span></a></li></ol></div></div></div><main id="content-outer"><div id="top-container" style="background-image: url(https://cdn.jsdelivr.net/gh/jerryc127/butterfly_cdn@2.1.0/top_img/index.jpg)"><div id="post-info"><div id="post-title"><div class="posttitle">《Effective Modeling of Encoder-Decoder Architecturefor Joint Entity and Relation Extraction》</div></div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 发表于 2020-03-04<span class="post-meta__separator">|</span><i class="fa fa-history fa-fw" aria-hidden="true"></i> 更新于 2020-03-04</time><span class="post-meta__separator">|</span><span><i class="fa fa-inbox post-meta__icon fa-fw" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/%E7%AC%94%E8%AE%B0/">笔记</a></span><div class="post-meta-wordcount"><div class="post-meta-pv-cv"><span><i class="fa fa-eye post-meta__icon fa-fw" aria-hidden="true"> </i>阅读量:</span><span id="busuanzi_value_page_pv"></span></div></div></div></div></div><div class="layout layout_post" id="content-inner">   <article id="post"><div class="article-container" id="post-content"><h1 id="abstract"><a class="markdownIt-Anchor" href="#abstract"></a> Abstract</h1>
<p>​       关系元组由两个实体以及它们之间的关系组成，并且经常在非结构化文本中找到这样的元组。文本中可能存在多个关系元组，并且它们之间可能共享一个或两个实体。从句子中提取这样的关系元组是一项艰巨的任务，并且在元组之间共享实体或重叠实体会使其更具挑战性。本文中提出了两种使用编码器-解码器体系结构共同提取实体和关系的方法。提出了一种用于关系元组的表示方案，该方案使解码器能够像机器翻译模型一样一次生成一个单词，并且仍然可以找到句子中存在的所有元组，它们具有不同长度的完整实体名称并且具有重叠的实体。提出一种基于指针网络的解码方法，其中在每个时间步生成一个完整的元组。</p>
<a id="more"></a>
<h1 id="Introduction" style="text-indent:0px;"><a name="t1"></a><a name="t1"></a>Introduction</h1>
<p style="text-indent:33px;">传统使用流水线方法，使用命名实体识别来识别句子中的实体，然后使用分类器查找它们之间的关系（或没有关系）。但是由于实体检测和关系分类的完全分离，这些模型错过了句子中存在的多个关系元组之间的交互作用。</p>
<p style="text-indent:33px;">本文三个主要挑战：（i）该模型能够将实体和关系提取在一起。 （ii）能够提取具有重叠实体的多个元组。 （iii）能够准确地提取一个具有全名的元组实体。为了解决这些挑战，提出了两种使用编码器-解码器体系结构的新颖方法。首先提出一种用于关系元组的新表示方案（表1），以便它可以用简单的方式表示具有重叠实体和不同长度实体的多个元组。采用编码器-解码器模型，其中解码器像机器翻译模型一样一次提取一个单词。在序列生成的最后，由于元组的独特表示，可以从单词序列中提取元组。尽管此模型执行得很好，但是一次生成一个单词对于此任务来说有点不自然。每个元组恰好具有两个实体和一个关系，并且每个实体在句子中显示为连续的文本范围。识别它们的最有效方法是在句子中找到它们的开始和结束位置。然后，<strong>使用五个元素来表示每个关系元组：两个实体的开始和结束位置以及它们之间的关系</strong>（请参见表1）。考虑到这一点，<strong>提出了一个基于指针网络的解码框架</strong>。该解码器由两个指针网络和一个识别它们之间关系的分类网络组成，该指针网络可以找到句子中两个实体的开始和结束位置。在解码的每个时间步，此解码器都提取整个关系元组，而不仅仅是单词。</p>
<p style="text-indent:33px;">本文的贡献如下：<strong>（1）提出了一种新的关系元组表示方法，使得一个编码器-解码器模型在每一步提取一个单词时，仍然可以从句子中找到多个实体重叠的元组和多个标记实体的元组，还提出了一种基于掩蔽的复制机制，只从源语句中提取实体。（2）提出在解码框架中使用指针网络进行修改，以使编码器-解码器模型更适合此任务。在每个时间步，此解码器都会提取整个关系元组，而不仅仅是单词。这个新的解码框架有助于加快训练过程，并使用更少的资源（GPU内存）。当从句子级元组提取转向文档级提取时，这将是一个重要因素。（3）对NYT数据集进行的实验表明，该方法明显优于所有以前的最新模型。</strong></p>
<h1 id="Task%20Description" style="text-indent:0px;"><a name="t2"></a><a name="t2"></a>Task Description</h1>
<p style="text-indent:33px;">关系元组由两个实体和一个关系组成。 这样的元组可以在句子中找到，其中实体是句子中的文本范围，并且关系来自预定义的集合R。这些元组可以在其中共享一个或两个实体。</p>
<ol><li style="text-indent:0px;">无实体重叠（NEO）：此类中的一个句子包含一个或多个元组，但它们不共享任何实体。</li>
	<li style="text-indent:0px;">实体对重叠（EPO）：此类中的一个句子有多个元组，并且至少两个元组以相同或相反的顺序共享两个实体。</li>
	<li style="text-indent:0px;">单实体重叠（SEO）：此类中的一个句子包含一个以上的元组，并且至少两个元组正好共享一个实体。</li>
</ol><p style="text-indent:0px;">一个句子可以同时属于EPO和SEO类，任务是提取句子中存在的所有关系元组。</p>
<h1 style="text-indent:0px;"><a name="t3"></a><a name="t3"></a>Encoder-Decoder Architecture</h1>
<p style="text-indent:33px;">此任务中输入是单词序列，输出是一组关系元组。第一种方法中，表示每个元组的ententity1；实体2;关系，使用“；”作为分隔符来分隔元组各部分，多行元组使用“ |”分隔。使用这些特殊标记，可以用一种简单的方式表示具有重叠实体和不同长度实体的多个关系元组。在推理过程中，序列生成结束后，可以使用这些特殊标记轻松提取关系元组。由于采用了这种统一的表示方案，对实体，关系和特殊标记的处理类似，因此编码器和解码器之间使用了包含所有这些标记的共享词汇。输入句子包含<strong>每个关系的线索词</strong>，可以帮助生成<strong>关系标记</strong>。其次使用两个特殊标记，以便模型可以区分关系元组的开头和元组组件的开头。为了使用编码器-解码器模型从句子中提取关系元组，该模型必须生成<strong>实体标记</strong>，找到关系线索词并将其映射到关系标记，并<strong>在适当的时间生成特殊标记</strong>。</p>
<p style="text-align:center;"><a href="https://img-blog.csdnimg.cn/20191216195622187.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTMxMTgx,size_16,color_FFFFFF,t_70" target="_blank" rel="noopener" data-fancybox="group" data-caption class="fancybox"><img alt class="has lazyload" height="213" width="1200" title data-src="https://img-blog.csdnimg.cn/20191216195622187.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTMxMTgx,size_16,color_FFFFFF,t_70"></a></p>
<h1 style="text-indent:0px;"><a name="t4"></a><a name="t4"></a>Embedding Layer &amp; Encoder</h1>
<p style="text-indent:33px;">创建一个单一词汇表V，该词表由源句标记、关系集R中的关系名称、特殊分隔符、目标序列开始标记（SOS）、目标序列结束标记（EOS）以及未知标记（UNK）。词级嵌入由两个部分组成：预训练词向量和基于字符嵌入的特征向量。使用单词嵌入层<a href="https://private.codecogs.com/gif.latex?E_%7B%5Comega%20%7D%5Cin%20%5Cmathbb%7BR%7D%5E%7B%5Cleft%20%7C%20V%20%5Cright%20%7C%5Ctimes%20d_%7B%5Comega%20%7D%7D" target="_blank" rel="noopener" data-fancybox="group" data-caption="E_{\omega }\in \mathbb{R}^{\left | V \right |\times d_{\omega }}" class="fancybox"><img alt="E_{\omega }\in \mathbb{R}^{\left | V \right |\times d_{\omega }}" class="mathcode lazyload" title="E_{\omega }\in \mathbb{R}^{\left | V \right |\times d_{\omega }}" data-src="https://private.codecogs.com/gif.latex?E_%7B%5Comega%20%7D%5Cin%20%5Cmathbb%7BR%7D%5E%7B%5Cleft%20%7C%20V%20%5Cright%20%7C%5Ctimes%20d_%7B%5Comega%20%7D%7D"></a>和字符嵌入层<a href="https://private.codecogs.com/gif.latex?E_%7Bc%7D%5Cin%20%5Cmathbb%7BR%7D%5E%7B%5Cleft%20%7C%20V%20%5Cright%20%7C%5Ctimes%20d_%7Bc%7D%7D" target="_blank" rel="noopener" data-fancybox="group" data-caption="E_{c}\in \mathbb{R}^{\left | V \right |\times d_{c}}" class="fancybox"><img alt="E_{c}\in \mathbb{R}^{\left | V \right |\times d_{c}}" class="mathcode lazyload" title="E_{c}\in \mathbb{R}^{\left | V \right |\times d_{c}}" data-src="https://private.codecogs.com/gif.latex?E_%7Bc%7D%5Cin%20%5Cmathbb%7BR%7D%5E%7B%5Cleft%20%7C%20V%20%5Cright%20%7C%5Ctimes%20d_%7Bc%7D%7D"></a>，其中dw是单词向量的维数，A是输入句子标记的字符字母，而dc是字符嵌入向量的维数。使用具有最大池化的卷积神经网络为每个单词提取维度为df的特征向量。串联词嵌入和基于字符嵌入的特征向量以获得输入标记的表示形式。源语句S由其标记x1; x2; ::::; xn的向量表示，其中<a href="https://private.codecogs.com/gif.latex?x_%7Bi%7D%5Cin%20%5Cmathbb%7BR%7D%5E%7Bd_%7Bw%7D&amp;plus;d_%7Bf%7D%7D" target="_blank" rel="noopener" data-fancybox="group" data-caption="x_{i}\in \mathbb{R}^{d_{w}+d_{f}}" class="fancybox"><img alt="x_{i}\in \mathbb{R}^{d_{w}+d_{f}}" class="mathcode lazyload" title="x_{i}\in \mathbb{R}^{d_{w}+d_{f}}" data-src="https://private.codecogs.com/gif.latex?x_%7Bi%7D%5Cin%20%5Cmathbb%7BR%7D%5E%7Bd_%7Bw%7D&amp;plus;d_%7Bf%7D%7D"></a>是第i个单词的向量表示形式，n是S的长度。这些向量xi被传递双向LSTM（Bi-LSTM）以获得隐藏的表示<a href="https://private.codecogs.com/gif.latex?h_%7Bi%7D%5E%7BE%7D" target="_blank" rel="noopener" data-fancybox="group" data-caption="h_{i}^{E}" class="fancybox"><img alt="h_{i}^{E}" class="mathcode lazyload" title="h_{i}^{E}" data-src="https://private.codecogs.com/gif.latex?h_%7Bi%7D%5E%7BE%7D"></a>。将Bi-LSTM的向前和向后LSTM的隐藏维设置为dh/2，以获得<a href="https://private.codecogs.com/gif.latex?h_%7Bi%7D%5E%7BE%7D%5Cin%20%5Cmathbb%7BR%7D%5E%7Bd_%7Bh%7D%7D" target="_blank" rel="noopener" data-fancybox="group" data-caption="h_{i}^{E}\in \mathbb{R}^{d_{h}}" class="fancybox"><img alt="h_{i}^{E}\in \mathbb{R}^{d_{h}}" class="mathcode lazyload" title="h_{i}^{E}\in \mathbb{R}^{d_{h}}" data-src="https://private.codecogs.com/gif.latex?h_%7Bi%7D%5E%7BE%7D%5Cin%20%5Cmathbb%7BR%7D%5E%7Bd_%7Bh%7D%7D"></a>，其中dh是后面描述的解码器的序列生成器LSTM的隐藏维度。</p>
<h1 style="text-indent:0px;"><a name="t5"></a><a name="t5"></a>Word-level Decoder &amp; Copy Mechanism</h1>
<p style="text-indent:33px;">目标序列T仅由标记y0; y1; ::::; ym的词嵌入向量表示，其中<a href="https://private.codecogs.com/gif.latex?y_%7Bi%7D%5Cin%20%5Cmathbb%7BR%7D%5E%7Bd_%7Bw%7D%7D" target="_blank" rel="noopener" data-fancybox="group" data-caption="y_{i}\in \mathbb{R}^{d_{w}}" class="fancybox"><img alt="y_{i}\in \mathbb{R}^{d_{w}}" class="mathcode lazyload" title="y_{i}\in \mathbb{R}^{d_{w}}" data-src="https://private.codecogs.com/gif.latex?y_%7Bi%7D%5Cin%20%5Cmathbb%7BR%7D%5E%7Bd_%7Bw%7D%7D"></a>是第i个标记的嵌入向量，m是目标序列的长度。 y0和ym分别代表SOS和EOS标记的嵌入向量。解码器一次生成一个标记，并在生成EOS时停止。使用LSTM作为解码器，在时间步t，解码器将源语句编码（<a href="https://private.codecogs.com/gif.latex?e_%7Bt%7D%5Cin%20%5Cmathbb%7BR%7D%5E%7Bd_%7Bh%7D%7D" target="_blank" rel="noopener" data-fancybox="group" data-caption="e_{t}\in \mathbb{R}^{d_{h}}" class="fancybox"><img alt="e_{t}\in \mathbb{R}^{d_{h}}" class="mathcode lazyload" title="e_{t}\in \mathbb{R}^{d_{h}}" data-src="https://private.codecogs.com/gif.latex?e_%7Bt%7D%5Cin%20%5Cmathbb%7BR%7D%5E%7Bd_%7Bh%7D%7D"></a>）和先前的目标词嵌入（<a href="https://private.codecogs.com/gif.latex?y_%7Bt-1%7D" target="_blank" rel="noopener" data-fancybox="group" data-caption="y_{t-1}" class="fancybox"><img alt="y_{t-1}" class="mathcode lazyload" title="y_{t-1}" data-src="https://private.codecogs.com/gif.latex?y_%7Bt-1%7D"></a>）作为输入，并生成当前标记的隐藏表示（<a href="https://private.codecogs.com/gif.latex?h_%7Bt%7D%5E%7BD%7D%5Cin%20%5Cmathbb%7BR%7D%5E%7Bd_%7Bh%7D%7D" target="_blank" rel="noopener" data-fancybox="group" data-caption="h_{t}^{D}\in \mathbb{R}^{d_{h}}" class="fancybox"><img alt="h_{t}^{D}\in \mathbb{R}^{d_{h}}" class="mathcode lazyload" title="h_{t}^{D}\in \mathbb{R}^{d_{h}}" data-src="https://private.codecogs.com/gif.latex?h_%7Bt%7D%5E%7BD%7D%5Cin%20%5Cmathbb%7BR%7D%5E%7Bd_%7Bh%7D%7D"></a>）。使用注意力机制获得句子编码向量<a href="https://private.codecogs.com/gif.latex?e_%7Bt%7D" target="_blank" rel="noopener" data-fancybox="group" data-caption="e_{t}" class="fancybox"><img alt="e_{t}" class="mathcode lazyload" title="e_{t}" data-src="https://private.codecogs.com/gif.latex?e_%7Bt%7D"></a>，使用具有权重矩阵<a href="https://private.codecogs.com/gif.latex?W_%7Bv%7D" target="_blank" rel="noopener" data-fancybox="group" data-caption="W_{v}" class="fancybox"><img alt="W_{v}" class="mathcode lazyload" title="W_{v}" data-src="https://private.codecogs.com/gif.latex?W_%7Bv%7D"></a>和偏差矢量<a href="https://private.codecogs.com/gif.latex?b_%7Bv%7D" target="_blank" rel="noopener" data-fancybox="group" data-caption="b_{v}" class="fancybox"><img alt="b_{v}" class="mathcode lazyload" title="b_{v}" data-src="https://private.codecogs.com/gif.latex?b_%7Bv%7D"></a>的线性层将<a href="https://private.codecogs.com/gif.latex?h_%7Bt%7D%5E%7BD%7D" target="_blank" rel="noopener" data-fancybox="group" data-caption="h_{t}^{D}" class="fancybox"><img alt="h_{t}^{D}" class="mathcode lazyload" title="h_{t}^{D}" data-src="https://private.codecogs.com/gif.latex?h_%7Bt%7D%5E%7BD%7D"></a>投影到词汇表V。</p>
<p style="text-align:center;"><a href="https://img-blog.csdnimg.cn/2019121620442334.png" target="_blank" rel="noopener" data-fancybox="group" data-caption class="fancybox"><img alt class="has lazyload" height="96" width="450" title data-src="https://img-blog.csdnimg.cn/2019121620442334.png"></a></p>
<p style="text-indent:0;"><a href="https://private.codecogs.com/gif.latex?%5Chat%7Bo%7D_%7Bt%7D" target="_blank" rel="noopener" data-fancybox="group" data-caption="\hat{o}_{t}" class="fancybox"><img alt="\hat{o}_{t}" class="mathcode lazyload" title="\hat{o}_{t}" data-src="https://private.codecogs.com/gif.latex?%5Chat%7Bo%7D_%7Bt%7D"></a>&nbsp;表示嵌入词汇表中所有单词在时间步t上的标准化分数，<a href="https://private.codecogs.com/gif.latex?h_%7Bt-1%7D%5E%7BD%7D" target="_blank" rel="noopener" data-fancybox="group" data-caption="h_{t-1}^{D}" class="fancybox"><img alt="h_{t-1}^{D}" class="mathcode lazyload" title="h_{t-1}^{D}" data-src="https://private.codecogs.com/gif.latex?h_%7Bt-1%7D%5E%7BD%7D"></a>&nbsp;是LSTM的前隐藏状态。</p>
<p style="text-indent:33px;">解码器的投影层将解码器输出映射到整个词汇表。然而在推断期间，解码器可以从词汇表中预测在当前句子或关系集或特殊标记中不存在的标记。为了防止这种情况，在投影层上应用softmax时进行mask，屏蔽词汇表的所有单词，但不包括当前源句标记、关系标记、分隔符UNK和EOS标记。要从softmax中屏蔽（排除）某些单词，将<a href="https://private.codecogs.com/gif.latex?%5Chat%7Bo%7D_%7Bt%7D" target="_blank" rel="noopener" data-fancybox="group" data-caption="\hat{o}_{t}" class="fancybox"><img alt="\hat{o}_{t}" class="mathcode lazyload" title="\hat{o}_{t}" data-src="https://private.codecogs.com/gif.latex?%5Chat%7Bo%7D_%7Bt%7D"></a>设置相应的值（负无穷），并且相应的softmax分数将为零，确保仅从源句子复制实体。在softmax操作中包含UNK标记，以确保模型在推理期间生成新实体。如果解码器预测到UNK标记，将其替换为具有最高关注分数的相应源单词。在推论过程中，解码完成后将基于特殊标记提取所有元组，从关系集中删除重复的元组和两个实体相同的元组或不包含关系标记的元组。此模型后称为WordDecoding（WDec）。</p>
<h1 style="text-indent:0px;"><a name="t6"></a><a name="t6"></a>Pointer Network-Based Decoder</h1>
<p style="text-indent:33px;">第二种方法使用开始和结束位置来识别句子中的实体。从单词词汇表中删除特殊标记和关系名称，并且单词嵌入仅在编码器侧与字符嵌入一起使用。在模型的解码器端使用附加的关系嵌入矩阵<a href="https://private.codecogs.com/gif.latex?E_%7Br%7D%5Cin%20%5Cmathbb%7BR%7D%5E%7B%5Cleft%20%7C%20R%20%5Cright%20%7C%5Ctimes%20d_%7Br%7D%7D" target="_blank" rel="noopener" data-fancybox="group" data-caption="E_{r}\in \mathbb{R}^{\left | R \right |\times d_{r}}" class="fancybox"><img alt="E_{r}\in \mathbb{R}^{\left | R \right |\times d_{r}}" class="mathcode lazyload" title="E_{r}\in \mathbb{R}^{\left | R \right |\times d_{r}}" data-src="https://private.codecogs.com/gif.latex?E_%7Br%7D%5Cin%20%5Cmathbb%7BR%7D%5E%7B%5Cleft%20%7C%20R%20%5Cright%20%7C%5Ctimes%20d_%7Br%7D%7D"></a>，其中R是关系集，dr是关系向量的维数。关系集R包括指示序列结束的。关系元组表示为序列T = y0; y1; ::: ;; ym，其中yt是一个元组，由源语句中的四个索引组成，指示两个实体的开始和结束位置以及它们之间的关系（请参见表1）。 y0是一个虚拟元组，表示序列的起始元组，而ym充当序列的结束元组，该序列具有EOS作为关系（该元组将忽略实体）。解码器由一个LSTM（具有隐藏维dh来生成元组序列）、两个指针网络（用于查找两个实体）以及分类网络（用于查找元组的关系）组成。在时间步骤t，解码器将源语句编码和所有先前生成的元组的表示&nbsp;<a href="https://private.codecogs.com/gif.latex?y_%7Bprev%7D" target="_blank" rel="noopener" data-fancybox="group" data-caption="y_{prev}" class="fancybox"><img alt="y_{prev}" class="mathcode lazyload" title="y_{prev}" data-src="https://private.codecogs.com/gif.latex?y_%7Bprev%7D"></a>&nbsp;作为输入，并生成当前元组的隐藏表示。句子编码向量集使用注意力机制获得。关系元组是一个集合，为了防止解码器再次生成相同的元组，在解码的每个时间步传递有关所有先前生成的元组的信息。yj是在时间步长j &lt;t预测的元组的向量表示，使用零向量（<a href="https://private.codecogs.com/gif.latex?y_%7B0%7D%3D%20%5Coverrightarrow%7B0%7D" target="_blank" rel="noopener" data-fancybox="group" data-caption="y_{0}= \overrightarrow{0}" class="fancybox"><img alt="y_{0}= \overrightarrow{0}" class="mathcode lazyload" title="y_{0}= \overrightarrow{0}" data-src="https://private.codecogs.com/gif.latex?y_%7B0%7D%3D%20%5Coverrightarrow%7B0%7D"></a>）表示伪元组y0，<a href="https://private.codecogs.com/gif.latex?h_%7Bt-1%7D%5E%7BD%7D" target="_blank" rel="noopener" data-fancybox="group" data-caption="h_{t-1}^{D}" class="fancybox"><img alt="h_{t-1}^{D}" class="mathcode lazyload" title="h_{t-1}^{D}" data-src="https://private.codecogs.com/gif.latex?h_%7Bt-1%7D%5E%7BD%7D"></a>是时间t-1处LSTM的隐藏状态。</p>
<p style="text-align:center;"><a href="https://img-blog.csdnimg.cn/20191217111201422.png" target="_blank" rel="noopener" data-fancybox="group" data-caption class="fancybox"><img alt class="has lazyload" height="92" width="500" title data-src="https://img-blog.csdnimg.cn/20191217111201422.png"></a></p>
<h1 style="text-indent:0px;"><a name="t7"></a><a name="t7"></a>Relation Tuple Extraction</h1>
<p style="text-indent:33px;">在获得当前元组&nbsp;<a href="https://private.codecogs.com/gif.latex?h_%7Bt%7D%5E%7BD%7D" target="_blank" rel="noopener" data-fancybox="group" data-caption="h_{t}^{D}" class="fancybox"><img alt="h_{t}^{D}" class="mathcode lazyload" title="h_{t}^{D}" data-src="https://private.codecogs.com/gif.latex?h_%7Bt%7D%5E%7BD%7D"></a>的隐藏表示之后，首先在源语句中找到两个实体的开始和结束指针。将向量<a href="https://private.codecogs.com/gif.latex?h_%7Bt%7D%5E%7BD%7D" target="_blank" rel="noopener" data-fancybox="group" data-caption="h_{t}^{D}" class="fancybox"><img alt="h_{t}^{D}" class="mathcode lazyload" title="h_{t}^{D}" data-src="https://private.codecogs.com/gif.latex?h_%7Bt%7D%5E%7BD%7D"></a>与编码器的隐藏向量<a href="https://private.codecogs.com/gif.latex?h_%7Bi%7D%5E%7BE%7D" target="_blank" rel="noopener" data-fancybox="group" data-caption="h_{i}^{E}" class="fancybox"><img alt="h_{i}^{E}" class="mathcode lazyload" title="h_{i}^{E}" data-src="https://private.codecogs.com/gif.latex?h_%7Bi%7D%5E%7BE%7D"></a>连接起来，然后将它们传递给具有dp隐藏维度的Bi-LSTM层，以实现向前和向后LSTM。 该Bi-LSTM层的隐藏向量<a href="https://private.codecogs.com/gif.latex?h_%7Bi%7D%5E%7Bk%7D%5Cin%20%5Cmathbb%7BR%7D%5E%7B2d_%7Bp%7D%7D" target="_blank" rel="noopener" data-fancybox="group" data-caption="h_{i}^{k}\in \mathbb{R}^{2d_{p}}" class="fancybox"><img alt="h_{i}^{k}\in \mathbb{R}^{2d_{p}}" class="mathcode lazyload" title="h_{i}^{k}\in \mathbb{R}^{2d_{p}}" data-src="https://private.codecogs.com/gif.latex?h_%7Bi%7D%5E%7Bk%7D%5Cin%20%5Cmathbb%7BR%7D%5E%7B2d_%7Bp%7D%7D"></a>被传递到具有softmax的两个前馈网络（FFN），以将每个隐藏向量转换为介于0和1之间的两个标量值，Softmax操作应用于输入句子中的所有单词。这两个标量值表示相应的源句子标记成为第一个实体的开始和结束位置的概率。带有两个前向层的Bi LSTM层是标识当前关系元组的第一个实体的第一个指针网络。</p>
<p style="text-align:center;"><a href="https://img-blog.csdnimg.cn/20191217113902143.png" target="_blank" rel="noopener" data-fancybox="group" data-caption class="fancybox"><img alt class="has lazyload" height="100" width="500" title data-src="https://img-blog.csdnimg.cn/20191217113902143.png"></a></p>
<p style="text-indent:0;"><a href="https://private.codecogs.com/gif.latex?s_%7Bi%7D%5E%7B1%7D%2Ce_%7Bi%7D%5E%7B1%7D" target="_blank" rel="noopener" data-fancybox="group" data-caption="s_{i}^{1},e_{i}^{1}" class="fancybox"><img alt="s_{i}^{1},e_{i}^{1}" class="mathcode lazyload" title="s_{i}^{1},e_{i}^{1}" data-src="https://private.codecogs.com/gif.latex?s_%7Bi%7D%5E%7B1%7D%2Ce_%7Bi%7D%5E%7B1%7D"></a>&nbsp;表示第i个源字词是预测元组第一个实体的开始和结束标记的标准化概率。然后使用另一个的指针网络提取元组的第二个实体，将隐向量<a href="https://private.codecogs.com/gif.latex?h_%7Bi%7D%5E%7Bk%7D" target="_blank" rel="noopener" data-fancybox="group" data-caption="h_{i}^{k}" class="fancybox"><img alt="h_{i}^{k}" class="mathcode lazyload" title="h_{i}^{k}" data-src="https://private.codecogs.com/gif.latex?h_%7Bi%7D%5E%7Bk%7D"></a>和<a href="https://private.codecogs.com/gif.latex?h_%7Bi%7D%5E%7BD%7D" target="_blank" rel="noopener" data-fancybox="group" data-caption="h_{i}^{D}" class="fancybox"><img alt="h_{i}^{D}" class="mathcode lazyload" title="h_{i}^{D}" data-src="https://private.codecogs.com/gif.latex?h_%7Bi%7D%5E%7BD%7D"></a>、<a href="https://private.codecogs.com/gif.latex?h_%7Bi%7D%5E%7BE%7D" target="_blank" rel="noopener" data-fancybox="group" data-caption="h_{i}^{E}" class="fancybox"><img alt="h_{i}^{E}" class="mathcode lazyload" title="h_{i}^{E}" data-src="https://private.codecogs.com/gif.latex?h_%7Bi%7D%5E%7BE%7D"></a>结合起来送第二个指针网络来获得<a href="https://private.codecogs.com/gif.latex?s_%7Bi%7D%5E%7B2%7D%25uFF0Ce_%7Bi%7D%5E%7B2%7D" target="_blank" rel="noopener" data-fancybox="group" data-caption="s_{i}^{2}，e_{i}^{2}" class="fancybox"><img alt="s_{i}^{2}，e_{i}^{2}" class="mathcode lazyload" title="s_{i}^{2}，e_{i}^{2}" data-src="https://private.codecogs.com/gif.latex?s_%7Bi%7D%5E%7B2%7D%25uFF0Ce_%7Bi%7D%5E%7B2%7D"></a>，<a href="https://private.codecogs.com/gif.latex?e_%7Bi%7D%5E%7B2%7D" target="_blank" rel="noopener" data-fancybox="group" data-caption="e_{i}^{2}" class="fancybox"><img alt="e_{i}^{2}" class="mathcode lazyload" title="e_{i}^{2}" data-src="https://private.codecogs.com/gif.latex?e_%7Bi%7D%5E%7B2%7D"></a>。标准化概率用来找寻两实体的向量表示。</p>
<p style="text-align:center;"><a href="https://img-blog.csdnimg.cn/20191217152116912.png" target="_blank" rel="noopener" data-fancybox="group" data-caption class="fancybox"><img alt class="has lazyload" height="86" width="500" title data-src="https://img-blog.csdnimg.cn/20191217152116912.png"></a></p>
<p style="text-indent:0;">然后将<a href="https://private.codecogs.com/gif.latex?a_%7Bt%7D%5E%7B1%7D%2Ca_%7Bt%7D%5E%7B2%7D" target="_blank" rel="noopener" data-fancybox="group" data-caption="a_{t}^{1},a_{t}^{2}" class="fancybox"><img alt="a_{t}^{1},a_{t}^{2}" class="mathcode lazyload" title="a_{t}^{1},a_{t}^{2}" data-src="https://private.codecogs.com/gif.latex?a_%7Bt%7D%5E%7B1%7D%2Ca_%7Bt%7D%5E%7B2%7D"></a>跟<a href="https://private.codecogs.com/gif.latex?h_%7Bt%7D%5E%7BD%7D" target="_blank" rel="noopener" data-fancybox="group" data-caption="h_{t}^{D}" class="fancybox"><img alt="h_{t}^{D}" class="mathcode lazyload" title="h_{t}^{D}" data-src="https://private.codecogs.com/gif.latex?h_%7Bt%7D%5E%7BD%7D"></a>结合送入带有sofamax的FFN来预测关系。</p>
<p style="text-align:center;"><a href="https://img-blog.csdnimg.cn/20191217154552776.png" target="_blank" rel="noopener" data-fancybox="group" data-caption class="fancybox"><img alt class="has lazyload" height="105" width="500" title data-src="https://img-blog.csdnimg.cn/20191217154552776.png"></a></p>
<p style="text-indent:0;"><a href="https://private.codecogs.com/gif.latex?r_%7Bt%7D" target="_blank" rel="noopener" data-fancybox="group" data-caption="r_{t}" class="fancybox"><img alt="r_{t}" class="mathcode lazyload" title="r_{t}" data-src="https://private.codecogs.com/gif.latex?r_%7Bt%7D"></a>&nbsp;表示时间步 t 时的预测关系的标准化概率，关系嵌入向量&nbsp;<a href="https://private.codecogs.com/gif.latex?z_%7Bt%7D" target="_blank" rel="noopener" data-fancybox="group" data-caption="z_{t}" class="fancybox"><img alt="z_{t}" class="mathcode lazyload" title="z_{t}" data-src="https://private.codecogs.com/gif.latex?z_%7Bt%7D"></a>&nbsp;通过对 <a href="https://private.codecogs.com/gif.latex?r_%7Bt%7D" target="_blank" rel="noopener" data-fancybox="group" data-caption="r_{t}" class="fancybox"><img alt="r_{t}" class="mathcode lazyload" title="r_{t}" data-src="https://private.codecogs.com/gif.latex?r_%7Bt%7D"></a>使用argmax函数&nbsp;和 <a href="https://private.codecogs.com/gif.latex?E_%7Br%7D" target="_blank" rel="noopener" data-fancybox="group" data-caption="E_{r}" class="fancybox"><img alt="E_{r}" class="mathcode lazyload" title="E_{r}" data-src="https://private.codecogs.com/gif.latex?E_%7Br%7D"></a>&nbsp;获得，<a href="https://private.codecogs.com/gif.latex?y_%7Bt%7D" target="_blank" rel="noopener" data-fancybox="group" data-caption="y_{t}" class="fancybox"><img alt="y_{t}" class="mathcode lazyload" title="y_{t}" data-src="https://private.codecogs.com/gif.latex?y_%7Bt%7D"></a>&nbsp;是时间步 t 预测元组的的向量表示。当预测关系为EOS时解码器停止序列生成过程。在推理过程中，选择两个实体的开始和结束位置以使四个指针概率的乘积最大化，同时保持两个实体不相互重叠且1 &lt;b &lt;e &lt;n的约束条件，其中b和e是相应实体的开始和结束位置。首先根据相应的起点和终点指针概率的最大积选择实体1的起点和终点，然后以类似的方式找到实体2，排除实体1的跨度以避免重叠。重复相同的过程，但是这次首先找到实体2然后是实体1。选择该对实体，这对实体在这两个选择之间给出了四个指针概率的较高乘积。此模型此后称为PtrNetDecoding（PNDec）。</p>
<h1 style="text-indent:0px;"><a name="t8"></a><a name="t8"></a>Attention Modeling</h1>
<p style="text-indent:33px;">针对词级解码模型使用三种不同的注意力机制，以获得源上下文向量<a href="https://private.codecogs.com/gif.latex?e_%7Bt%7D" target="_blank" rel="noopener" data-fancybox="group" data-caption="e_{t}" class="fancybox"><img alt="e_{t}" class="mathcode lazyload" title="e_{t}" data-src="https://private.codecogs.com/gif.latex?e_%7Bt%7D"></a>&nbsp;：</p>
<ol><li style="text-indent:0px;">Avg：上下文向量是通过平均编码的隐藏向量来获得的。</li>
	<li style="text-indent:0px;">
	<p style="text-align:center;"><a href="https://img-blog.csdnimg.cn/20191217162901831.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTMxMTgx,size_16,color_FFFFFF,t_70" target="_blank" rel="noopener" data-fancybox="group" data-caption class="fancybox"><img alt class="has lazyload" height="309" width="500" title data-src="https://img-blog.csdnimg.cn/20191217162901831.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTMxMTgx,size_16,color_FFFFFF,t_70"></a></p>
	</li>
	<li style="text-indent:0px;">
	<p style="text-align:center;"><a href="https://img-blog.csdnimg.cn/20191217162924798.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTMxMTgx,size_16,color_FFFFFF,t_70" target="_blank" rel="noopener" data-fancybox="group" data-caption class="fancybox"><img alt class="has lazyload" height="338" width="500" title data-src="https://img-blog.csdnimg.cn/20191217162924798.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTMxMTgx,size_16,color_FFFFFF,t_70"></a></p>
	对于基于指针网络的解码模型使用single注意模型的三个变体。一使用<a href="https://private.codecogs.com/gif.latex?h_%7Bt-1%7D%5E%7BD%7D" target="_blank" rel="noopener" data-fancybox="group" data-caption="h_{t-1}^{D}" class="fancybox"><img alt="h_{t-1}^{D}" class="mathcode lazyload" title="h_{t-1}^{D}" data-src="https://private.codecogs.com/gif.latex?h_%7Bt-1%7D%5E%7BD%7D"></a>在注意力机制中计算<a href="https://private.codecogs.com/gif.latex?q_%7Bt%7D%5E%7Bi%7D" target="_blank" rel="noopener" data-fancybox="group" data-caption="q_{t}^{i}" class="fancybox"><img alt="q_{t}^{i}" class="mathcode lazyload" title="q_{t}^{i}" data-src="https://private.codecogs.com/gif.latex?q_%7Bt%7D%5E%7Bi%7D"></a>，二使用<a href="https://private.codecogs.com/gif.latex?y_%7Bprev%7D" target="_blank" rel="noopener" data-fancybox="group" data-caption="y_{prev}" class="fancybox"><img alt="y_{prev}" class="mathcode lazyload" title="y_{prev}" data-src="https://private.codecogs.com/gif.latex?y_%7Bprev%7D"></a>计算<a href="https://private.codecogs.com/gif.latex?q_%7Bt%7D%5E%7Bi%7D" target="_blank" rel="noopener" data-fancybox="group" data-caption="q_{t}^{i}" class="fancybox"><img alt="q_{t}^{i}" class="mathcode lazyload" title="q_{t}^{i}" data-src="https://private.codecogs.com/gif.latex?q_%7Bt%7D%5E%7Bi%7D"></a>&nbsp;，三使用<a href="https://private.codecogs.com/gif.latex?h_%7Bt-1%7D%5E%7BD%7D" target="_blank" rel="noopener" data-fancybox="group" data-caption="h_{t-1}^{D}" class="fancybox"><img alt="h_{t-1}^{D}" class="mathcode lazyload" title="h_{t-1}^{D}" data-src="https://private.codecogs.com/gif.latex?h_%7Bt-1%7D%5E%7BD%7D"></a>和<a href="https://private.codecogs.com/gif.latex?y_%7Bprev%7D" target="_blank" rel="noopener" data-fancybox="group" data-caption="y_{prev}" class="fancybox"><img alt="y_{prev}" class="mathcode lazyload" title="y_{prev}" data-src="https://private.codecogs.com/gif.latex?y_%7Bprev%7D"></a>获得的两个注意向量进行级联来获得注意上下文向量。通过基于指针网络的解码模型，可以提供最佳性能。&nbsp;</li>
</ol><h1 style="text-indent:0px;"><a name="t9"></a><a name="t9"></a>Loss Funtion</h1>
<p style="text-align:center;"><a href="https://img-blog.csdnimg.cn/20191217164256868.png" target="_blank" rel="noopener" data-fancybox="group" data-caption class="fancybox"><img alt class="has lazyload" height="157" width="500" title data-src="https://img-blog.csdnimg.cn/20191217164256868.png"></a></p>
<p style="text-indent:0px;"><a href="https://private.codecogs.com/gif.latex?v_%7Bt%7D%5E%7Bb%7D" target="_blank" rel="noopener" data-fancybox="group" data-caption="v_{t}^{b}" class="fancybox"><img alt="v_{t}^{b}" class="mathcode lazyload" title="v_{t}^{b}" data-src="https://private.codecogs.com/gif.latex?v_%7Bt%7D%5E%7Bb%7D"></a>&nbsp;是单词级解码中时间步t处目标单词的softmax得分，r/s/e 是实体相应的真实关系标签、真实start和end指针位置的softmax得分，b/t/r 是第b个训练实例、解码时间步t和一个元组的两个实体，B/T分别是batch size和解码器的最大时间步。</p>
<p style="text-indent:0px;">&nbsp;</p>
<p style="text-indent:0;">&nbsp;</p>
<p style="text-indent:0;">&nbsp;</p>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">R</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://yoursite.com/2020/03/04/article-3/">http://yoursite.com/2020/03/04/article-3/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://yoursite.com">想吃煎饼果子</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E8%AE%BA%E6%96%87%E8%AE%B0%E5%BD%95/">论文记录    </a><a class="post-meta__tags" href="/tags/NLP/">NLP    </a></div><div class="post_share"><div class="social-share" data-image="/img/avatar.png" data-sites="wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js"></script></div></div><div class="post-reward"><a class="reward-button button--primary button--animated"> <i class="fa fa-qrcode"></i> 打赏<div class="reward-main"><ul class="reward-all"><li class="reward-item"><img class="lazyload post-qr-code__img" src="/img/wechat.jpg" alt="微信"><div class="post-qr-code__desc">微信</div></li><li class="reward-item"><img class="lazyload post-qr-code__img" src="/img/alipay.jpg" alt="支付宝"><div class="post-qr-code__desc">支付宝</div></li></ul></div></a></div><nav class="pagination_post" id="pagination"><div class="prev-post pull_left"><a href="/2020/03/04/article-4/"><img class="prev_cover lazyload" data-src="false" onerror="onerror=null;src='/img/404.jpg'"><div class="label">上一篇</div><div class="prev_info"><span>《Extracting Relational Facts by an End-to-End Neural Model with Copy Mechanism》记录</span></div></a></div><div class="next-post pull_right"><a href="/2020/03/04/article/"><img class="next_cover lazyload" data-src="false" onerror="onerror=null;src='/img/404.jpg'"><div class="label">下一篇</div><div class="next_info"><span>《Attention Guided Graph Convolutional Networks for Relation Extraction》阅读记录</span></div></a></div></nav></div></main><footer id="footer" data-type="color"><div id="footer-wrap"><div class="copyright">&copy;2020 By R</div><div class="framework-info"><span>驱动 </span><a href="http://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 </span><a href="https://github.com/jerryc127/hexo-theme-butterfly" target="_blank" rel="noopener"><span>Butterfly</span></a></div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="阅读模式"></i><i class="fa fa-plus" id="font_plus" title="放大字体"></i><i class="fa fa-minus" id="font_minus" title="缩小字体"></i><i class="darkmode fa fa-moon-o" id="darkmode" title="夜间模式"></i></div><div id="rightside-config-show"><div id="rightside_config" title="设置"><i class="fa fa-cog" aria-hidden="true"></i></div><i class="fa fa-list-ul close" id="mobile-toc-button" title="目录" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="回到顶部" aria-hidden="true"></i></div></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@latest/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/lazysizes@latest/lazysizes.min.js" async=""></script></body></html>